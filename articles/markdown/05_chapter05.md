# 第5章　QRコードに未来を込めて

---

　二週間は、三百三十六時間だ。

　蓮はミートアップの翌朝、カレンダーアプリに期限を入力しながらその数字を眺めた。三百三十六。フルタイムで開発に充てられるのは一日十二時間として、百六十八時間。睡眠と食事と風呂を引くと、実質はもっと少ない。

　しかし蓮には、三つの武器があった。

　一つ、Next.jsとReactの三年間の経験。二つ、J-CoinのSDKドキュメント。三つ、Discordの向こう側にいるkirishi_maと美華。

　足りないものは山ほどある。でも、足りているもので始めるしかない。

　蓮はターミナルを開いた。昨夜`create-next-app`で生成したプロジェクトが、まだ骨組みだけの状態で待っている。`src/app/page.tsx`に書いた「ここから始める」の一行を見つめ、それを消した。

　白紙に戻る。

　ここから先は、設計だ。

---

　最初の二時間を、蓮はコードを一行も書かずに過ごした。

　紙のノートを広げ、決済の流れを上から下まで書き出す。登場人物は二人。店主と客。店主がタブレットで金額を入力する。QRコードが表示される。客がスマートフォンでスキャンする。ウォレットが開く。J-Coinが送金される。店主の画面に「決済完了」と表示される。

　六つのステップ。言葉にすれば三十秒で読める。しかし、それぞれのステップの裏側に技術が潜んでいる。

　蓮はノートの右半分に、技術的な構成要素を書き出した。

```
【フロントエンド】 Next.js + TypeScript + Tailwind CSS
【ウォレット接続】 RainbowKit + Wagmi
【トークン送金】   ERC-20 transfer（ethers.js / viem）
【QRコード生成】   qrcodeライブラリ
【データベース】   Prisma + PostgreSQL
【認証】           NextAuth.js（店舗アカウント）
```

　Next.jsを選ぶ理由は明確だった。三年間で最も手に馴染んだフレームワーク。サーバーサイドレンダリング、APIルート、ファイルベースのルーティング。一人で開発するなら、フロントエンドもバックエンドもNext.js一本で完結させるのが最速だ。

　TypeScriptは議論の余地がない。金を扱うアプリで型のないコードを書くのは、暗闇で手術するようなものだ。

　問題は、ブロックチェーンとの接続部分だった。

　RainbowKitとWagmi。第二章でSDKのドキュメントを読んだときに名前だけは知っていた。RainbowKitはウォレット接続のUIコンポーネント。Wagmiはそれを支えるReactフック集。この二つを組み合わせれば、MetaMaskやWalletConnectなど複数のウォレットに対応した接続画面を、ほとんどゼロから書かずに実装できる。

　蓮はまだ使ったことがない。

　でも、ドキュメントを読む限り、Reactの作法に忠実な設計だった。`Provider`でラップし、フックで状態を取り、コンポーネントでUIを出す。蓮の土俵だ。ブロックチェーンの部分だけが未知で、それ以外はいつものReact開発と変わらない。

　「SDKが吸収してくれるはず」——ミートアップで美華に言った自分の言葉を思い出す。吸収してくれないものは、自分で書く。

　蓮はノートを閉じ、キーボードに向かった。

---

　一日目。ウォレット接続。

　`npm install @rainbow-me/rainbowkit wagmi viem`

　三つのパッケージをインストールする間に、設定ファイルを書き始めた。Wagmiの設定——どのブロックチェーンに接続するかを宣言する。蓮はPolygon Amoyテストネットを指定した。本番（メインネット）はまだ早い。まずはテストネットで動くものを作る。

```typescript
import { getDefaultConfig } from '@rainbow-me/rainbowkit';
import { polygonAmoy } from 'wagmi/chains';

const config = getDefaultConfig({
  appName: 'J-Coin Pay',
  projectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID!,
  chains: [polygonAmoy],
  ssr: true,
});
```

　たったこれだけ。アプリ名、WalletConnectのプロジェクトID、接続先のチェーン、SSR対応フラグ。四行の設定で、Polygon上のウォレット接続基盤が整う。

　次に、アプリ全体をProviderでラップする。RainbowKitが提供する`RainbowKitProvider`と、WagmiのQueryClientProviderを重ねる。Reactの世界では「コンテキスト」と呼ばれるパターンだ。木の根元に栄養を注ぐと、枝葉のどのコンポーネントからでもその栄養——この場合はウォレットの接続状態——にアクセスできる。

　画面にRainbowKitの「Connect Wallet」ボタンが表示された瞬間、蓮は自分のスマートフォンでMetaMaskを開いた。テストネットに切り替え、WalletConnect経由で接続を試みる。

　スマートフォンにポップアップが表示された。「J-Coin Payに接続しますか？」

　蓮は「承認」をタップした。

　パソコンの画面が切り替わった。ボタンの文字が「Connect Wallet」からウォレットアドレスの先頭と末尾——`0x7a3F...9dC2`——に変わる。

　接続成功。

　蓮は椅子の背もたれに体を預けた。これが、RainbowKitの力だ。ウォレット選択画面、QRコード表示、接続状態の管理、ネットワーク切り替え。通常なら数百行のコードが必要な機能を、数行のインポートと設定で実現できる。

　SDKとライブラリが、蓮のブロックチェーン歴の浅さを補ってくれている。自分が三年かけて培ったReactのスキルと、コミュニティが何年もかけて磨いてきたOSSの組み合わせ。一人だけど、一人じゃない。

---

　二日目。データベース設計。

　蓮にとって、これは得意分野のはずだった。SIer時代に何十回と書いたER図。テーブル定義。リレーション。しかし今回は、「普通」のデータベース設計とは前提が一つ違う。

　ブロックチェーンにも記録がある。

　J-Coinの送金はPolygonのブロックチェーン上に記録される。では、なぜアプリ側にもデータベースが必要なのか。ブロックチェーンだけで完結するなら、Prismaは要らないはずだ。

　蓮は十分ほど考えて、答えを出した。

　ブロックチェーンは「トランザクション」を記録する。誰が誰にいくら送ったか。しかし「決済リクエスト」——つまり「この金額を払ってください」という店側の要求——は、ブロックチェーンには存在しない。QRコードを表示し、有効期限を管理し、支払い済みかどうかのステータスを追跡する。それはアプリの仕事だ。

　ブロックチェーンは送金の真実を記録する。アプリのデータベースは、その送金と商売の文脈をつなぐ。

　蓮はPrismaのスキーマファイルを開いた。

```prisma
model PaymentRequest {
  id        String   @id @default(cuid())
  userId    String
  nonce     String   @unique
  amount    String
  toAddress String
  status    PaymentStatus @default(PENDING)
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user        User         @relation(fields: [userId], references: [id])
  transaction Transaction?
}

enum PaymentStatus {
  PENDING
  COMPLETED
  EXPIRED
  CANCELLED
}
```

　蓮の指が止まったのは、`amount`の型を書くときだった。

　直感的には`Float`か`Int`を使いたくなる。金額なのだから、数値型であるべきだ。しかし第三章で学んだことを思い出す。J-Coinは`decimals = 18`。一J-Coinは内部で`1000000000000000000`——十の十八乗——として表現される。この巨大な整数をデータベースの通常の数値型に入れると、精度が失われる可能性がある。

　`String`。文字列として保存する。見た目は不格好だが、精度は一桁も失われない。お金を扱うとき、「だいたい正しい」は許されない。一円のずれが、信頼を壊す。

　もう一つ、蓮が慎重に設計したフィールドがあった。

　`nonce`。

---

　ノンスという概念を、蓮はSIer時代にCSRF対策で使ったことがあった。「一度きりの使い捨て番号」。リクエストの一意性を保証し、同じリクエストが二度処理されることを防ぐ。

　QRコード決済における最悪のシナリオを、蓮は想像した。

　客がQRコードをスキャンし、J-Coinを送金する。ネットワークが遅延し、客の画面に「送金完了」が表示されない。不安になった客がもう一度送金ボタンを押す。二重支払い。五百円のコーヒーに千円を払わせてしまう。

　あるいは——悪意のあるケース。同じQRコードのスクリーンショットを保存しておき、後から別の送金に使い回す。

　どちらも、ノンスで防げる。

```typescript
import { randomBytes } from 'crypto';

export function generateNonce(): string {
  return randomBytes(16).toString('hex');
}
```

　十六バイトの暗号学的乱数を生成し、三十二文字の十六進数文字列に変換する。`a3f8c1d9e7b2054f6a9d3c8e1b7f4a20`。こんな文字列が、決済リクエストごとに一つずつ割り当てられる。データベースの`@unique`制約により、同じノンスを持つ決済リクエストは二度と作れない。

　一つのQRコードに、一つのノンス。一つのノンスに、一つの決済。それ以上でもそれ以下でもない。

　蓮はTransactionモデルも書いた。

```prisma
model Transaction {
  id               String   @id @default(cuid())
  paymentRequestId String   @unique
  txHash           String   @unique
  fromAddress      String
  toAddress        String
  amount           String
  status           TransactionStatus @default(PENDING)
  blockNumber      Int?
  confirmedAt      DateTime?

  paymentRequest PaymentRequest @relation(fields: [paymentRequestId], references: [id])
}
```

　`paymentRequestId`に`@unique`。一つの決済リクエストに対して、トランザクションは一つだけ。`txHash`にも`@unique`。ブロックチェーン上の同じトランザクションが、二度記録されることはない。

　二重の鍵。ノンスでリクエストの一意性を守り、トランザクションハッシュで支払いの一意性を守る。ベルトとサスペンダー。どちらか一方が外れても、もう一方が支えてくれる。

　蓮は`npx prisma db push`を実行した。スキーマがデータベースに反映される。テーブルが生まれた。まだ空のテーブル。しかしその構造の中に、蓮が考え得るかぎりの安全策が埋め込まれている。

---

　三日目から五日目。決済フローの実装。

　蓮はここで、最初の壁にぶつかった。

　店舗側の画面は簡単だった。金額を入力するテンキー、「QRコード生成」ボタン、そしてQRコードの表示。Next.jsのAPIルートを一つ書けばいい。

```typescript
// /api/payment/create
const nonce = generateNonce();
const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5分後

const paymentRequest = await prisma.paymentRequest.create({
  data: {
    userId: session.user.id,
    nonce,
    amount,
    toAddress: user.walletAddress,
    status: 'PENDING',
    expiresAt,
  },
});
```

　決済リクエストを生成し、五分間の有効期限を設定する。五分。蓮はこの数字を何度も考え直した。短すぎれば客が焦る。長すぎればセキュリティリスクが高まる。コンビニのQRコード決済が表示から約五分で失効することを思い出し、同じ水準を採用した。

　生成されたリクエストのIDから、決済ページのURLを作る。そのURLをQRコードに変換する。

```typescript
import QRCode from 'qrcode';

const paymentUrl = `${process.env.NEXT_PUBLIC_APP_URL}/pay/${paymentRequest.id}`;
const qrDataUrl = await QRCode.toDataURL(paymentUrl, {
  width: 300,
  margin: 2,
  errorCorrectionLevel: 'M',
});
```

　三百ピクセル四方。マージン二。エラー訂正レベルM。QRコードが画面に表示された。スマートフォンのカメラで読み取ると——決済ページが開く。

　問題は、その先だった。

　決済ページ。客がQRコードを読み取ったあとに表示される画面。ここでウォレットを接続し、J-Coinを送金する。この画面の設計で、蓮は三日間を費やした。

　技術的な難しさではない。UIの難しさだ。

　ウォレットを接続するボタン。送金金額の表示。送金実行ボタン。確認中のスピナー。完了のメッセージ。要素を並べるだけなら三十分で終わる。しかし蓮は、根津の顔を思い出していた。

　「画面の中の数字を『お金です』って言われても、俺にはピンとこないんだよ」

　客側はともかく、店舗側の画面は根津が使う。五十八歳。スマートフォンのフリック入力すら怪しい人間が、迷わず操作できなければならない。

　蓮は画面から要素を削り始めた。

　ウォレットアドレスの全文表示？　いらない。根津には意味不明な文字列だ。トランザクションハッシュ？　いらない。ブロック番号？　論外。ガス代の内訳？　根津に見せたら「何の話だ」と言われる。

　残ったのは三つだけだった。金額。QRコード。ステータス。

　金額は大きなフォントで「¥500」と表示する。「500 J-Coin」ではない。「¥500」。J-Coinは一コインが一円だ。ならば円記号で見せるほうが、根津には伝わる。裏側でJ-Coinが動いていることを、根津は知らなくていい。

　QRコードは画面の中央に、できる限り大きく。客がスマートフォンをかざしたとき、一瞬で読み取れるサイズ。

　ステータスは色で示す。待機中は青。決済完了は緑。期限切れは灰色。文字を読まなくても、色だけで状態が分かる。

　kirishi_maの言葉が蘇る。「ユーザーが見える画面に、ブロックチェーンという単語を一文字も出すな」。

　蓮はその教えを、一ピクセル単位で守った。

---

　六日目の夜。蓮はねづ珈琲にいた。

　開発を始めてから、蓮は毎日この店に通っていた。自宅で作業するよりも、ここのカウンターで作業するほうが集中できた。コーヒーの香りと、根津の背中と、ときおり聞こえる常連客の世間話。その生活音が、蓮のコードに地面をつけてくれる。

　自宅のモニターだけを見ていると、自分が何を作っているのか忘れそうになる。でもここにいれば、コードの先にいる人間の顔が見える。

　根津は蓮がノートパソコンを開いていても何も言わなかった。「仕事か」と一度だけ聞き、蓮が頷くと、それきり干渉してこない。ただ、カップが空になると黙って次のコーヒーを淹れてくれた。

「根津さん」

「ん」

「お客さんがカードで払うとき、お店側ではどういう操作をしてますか」

　根津は手を止めずに答えた。「端末にカードを差すかかざすかして、暗証番号を入れてもらう。それだけだ」

「金額の入力は？」

「レジで打った金額がそのまま端末に飛ぶ。連動してる」

「じゃあ、もしレジと連動してなかったら？」

「うちの古いレジは連動してないよ。だから端末に手で金額を打ち込んでる」

「それ、面倒ですか」

「面倒だよ。急いでるときに限って打ち間違える」

　蓮はノートに走り書きした。金額入力は大きなテンキー。打ち間違いを防ぐ確認画面。根津の「面倒だよ」から逆算する。

「なんだ、決済端末でも作ってるのか」

「……近いです」

「ふうん」

　根津はそれ以上聞かなかった。蓮が何を作っているか、おそらく察している。だが聞かない。興味がないのではなく、前回断ったことを覚えているのだ。蓮が再び「使ってくれ」と言い出すまで、自分からは触れない——それが根津の流儀だった。

　蓮はコードに戻った。テンキーUIのCSSを調整しながら、ボタンのサイズを指一本でタップしやすい大きさに広げた。根津のごつい指を思い浮かべながら。

---

　八日目。決済完了の検知。

　ここが、最も厄介だった。

　客がJ-Coinを送金する。そのトランザクションがPolygonのネットワークに送信され、バリデータに承認され、ブロックに取り込まれる。所要時間は二秒から十秒。しかし蓮のアプリは、その「承認された」という事実をどうやって知るのか。

　最もシンプルな方法は、ポーリングだ。三秒ごとにサーバーへ問い合わせ、「この決済リクエスト、まだPENDING？　もうCOMPLETED？」と確認する。原始的だが、確実に動く。

```typescript
// 店舗側: 3秒ごとにステータスを確認
useEffect(() => {
  const interval = setInterval(async () => {
    const res = await fetch(`/api/payment/${paymentRequestId}`);
    const data = await res.json();
    if (data.status === 'COMPLETED') {
      clearInterval(interval);
      onPaymentComplete(data);
    }
  }, 3000);
  return () => clearInterval(interval);
}, [paymentRequestId]);
```

　しかしこのポーリングは、店舗側の「待つ」仕組みにすぎない。もっと重要な問題は、サーバー側でトランザクションの正当性を検証するロジックだ。

　客のウォレットアプリが送金を実行すると、トランザクションハッシュが返される。六十四桁の十六進数。`0x`で始まる、世界に一つだけの識別子。そのハッシュを蓮のサーバーに送信し、サーバーがブロックチェーン上のトランザクションを検証する。

　送金先は正しいか。金額は正しいか。そしてそのトランザクションは、本当にブロックに含まれているか。

　蓮はAPIルートを書いた。

```typescript
// トランザクションの検証
const receipt = await provider.getTransactionReceipt(txHash);
if (!receipt) {
  return NextResponse.json({ error: 'Transaction not found' }, { status: 404 });
}
```

　ブロックチェーンのノードに問い合わせ、トランザクションのレシートを取得する。レシートが存在すれば、そのトランザクションはブロックに取り込まれている。存在しなければ、まだ未確認か、存在しない。

　さらに、レシートの中のイベントログを解析する。ERC-20の`Transfer`イベント。第三章で読んだ`emit Transfer(owner, to, amount)`の痕跡が、ここに記録されている。

　送金先アドレスが、決済リクエストの`toAddress`と一致するか。金額がリクエストの`amount`と一致するか。一つでも食い違えば、その送金はこの決済リクエストに対するものではない。

　検証をパスしたら、`PaymentRequest`のステータスを`COMPLETED`に、`Transaction`レコードを`CONFIRMED`で作成する。この二つの操作は同時に成功するか、同時に失敗するかでなければならない。片方だけ成功すると、データの整合性が壊れる。

```typescript
await prisma.$transaction([
  prisma.transaction.create({
    data: {
      paymentRequestId: paymentRequest.id,
      txHash,
      fromAddress,
      toAddress,
      amount,
      status: 'CONFIRMED',
      blockNumber: receipt.blockNumber,
      confirmedAt: new Date(),
    },
  }),
  prisma.paymentRequest.update({
    where: { id: paymentRequest.id },
    data: { status: 'COMPLETED' },
  }),
]);
```

　`prisma.$transaction`。二つのデータベース操作をアトミックに実行する。「原子的」——それ以上分割できない一つの塊として扱う。片方が失敗すれば、もう片方もロールバックされる。

　蓮はこのコードを書いたとき、第三章で読んだスマートコントラクトの`transfer`関数を思い出した。あの関数も、残高の減算と加算を一つの処理としてまとめていた。「引いて、足して、記録する」。ブロックチェーンの世界でもアプリの世界でも、お金を扱うコードの核心は同じだ。一つの操作が途中で止まってはならない。

---

　十日目の夜。蓮はDiscordで美華に泣きついた。

> **fujisaki_ren**: 決済ページで、チェーン切り替えのUIがうまく動かない。ユーザーがPolygon以外のネットワークにいるとき、切り替えを促すんだけど、MetaMaskのポップアップが出ないケースがある。

> **MeiHua_Chen**: あー、それ私もハマった！ Wagmiの`useSwitchChain`フック使ってる？

> **fujisaki_ren**: はい、でもリジェクトされたときのエラーハンドリングが……

> **MeiHua_Chen**: `UserRejectedRequestError`をキャッチして、「ネットワークをPolygonに切り替えてください」ってメッセージ出すのが一番わかりやすいよ。ユーザーが手動で切り替える場合もあるから、`useAccount`の`chain`を監視して、正しいチェーンに変わったら自動でUIを更新する。

> **fujisaki_ren**: なるほど……ちょっとやってみます。

　十五分後。

> **fujisaki_ren**: 動いた！ ありがとう美華さん。

> **MeiHua_Chen**: よかった😊 私もクロスボーダーのやつでWagmiのフック全部使い倒してるから、何かあったら聞いて。エコシステムの仲間でしょ。

　蓮はチャットを閉じながら、ミートアップで丘部が言った言葉を思い出した。「誰かが走り出すと、周りが勝手に動き始める」。蓮が走り出したことで、美華が手を差し伸べてくれる。美華が走っているから、蓮も質問できる。エコシステムは、技術の共有だけでなく、人間の相互作用でもあった。

---

　十二日目。

　蓮は朝からねづ珈琲のカウンターにいた。開発十二日目。残り二日。

　コードはほぼ書き終えていた。店舗側の管理画面。決済ページ。ウォレット接続。QRコード生成。ステータス管理。ノンスによる二重支払い防止。トランザクション検証。認証。

　残っているのは、通しテストだった。

　蓮はテストネットのJ-Coinを用意した。第二章でフォーセットから取得したテストトークンがまだウォレットに残っている。もう一つ、店舗側のウォレットとしてAccount 2を用意し、テスト用の店舗アカウントをアプリに登録した。

　すべてのピースが揃った。

　蓮は深呼吸した。

　店舗側の画面でテンキーを操作し、「500」と入力した。「QR生成」ボタンをタップ。画面の中央に、白黒のモザイク模様が現れた。QRコード。その下に、大きな文字で「¥500」。ステータスバーは青。「お支払い待ち」。

　有効期限のカウントダウンが始まった。`4:59`、`4:58`、`4:57`——

　蓮はスマートフォンを手に取り、カメラをQRコードに向けた。読み取り。ブラウザが開く。決済ページ。

　「J-Coin Pay」というタイトルと、「¥500」という金額表示。その下に、青いボタン——「ウォレットを接続」。

　タップ。RainbowKitのモーダルが開く。MetaMaskを選択。アプリが切り替わり、「J-Coin Payに接続しますか？」。承認。

　決済ページに戻る。ウォレットが接続された。アドレスの先頭と末尾が表示されている。金額の下に、新しいボタンが現れた。

　「¥500を支払う」。

　蓮の指が、ボタンの上で止まった。

　たかがテストネットだ。テスト用のトークンだ。失敗しても何も失わない。それなのに、心臓が速い。二週間ぶんの設計と実装とデバッグが、このボタンの向こうに集約されている。

　押した。

　MetaMaskが開いた。トランザクションの確認画面。送金先、金額、ガス代の見積もり。「確認」をタップ。

　決済ページに戻る。画面中央でスピナーが回っている。「確認中……」

　蓮はスマートフォンを置き、パソコンの画面に目を移した。店舗側の画面。QRコードの下のステータスバーはまだ青。「お支払い待ち」のまま。ポーリングが三秒ごとにサーバーへ問い合わせている。

　三秒。

　六秒。

　九秒——

　画面が変わった。

　ステータスバーが青から緑に切り替わった。QRコードが消え、代わりに大きなチェックマークが表示された。

　「決済完了」

　蓮のスマートフォンの画面にも、ほぼ同時に「お支払い完了」と表示されていた。

　動いた。

　蓮は両手をキーボードの上に置いたまま、三秒間動けなかった。

　テストネットの、テストトークンの、たった一回の送金。本番環境から見ればゼロに等しい。根津の前でデモするにはまだ粗い部分がある。エラーハンドリングも、エッジケースの処理も、まだ足りていない。

　でも——動いた。

　蓮が設計したデータベースにノンスが記録され、QRコードが生成され、客のウォレットからJ-Coinが送金され、ブロックチェーン上でトランザクションが承認され、サーバーがその正当性を検証し、ステータスが`PENDING`から`COMPLETED`に遷移した。蓮が書いたコードの、最初の一行目から最後の一行まで、すべてが意図どおりにつながった。

　蓮は小さく、拳を握った。

「おい」

　声に振り向くと、根津がカウンター越しに蓮のパソコンの画面を覗き込んでいた。いつからそこにいたのか。

「何やってんだ。急にニヤニヤして」

「……コーヒー、もう一杯もらえますか」

「今ので四杯目だぞ。胃に穴が開くぞ」

「大丈夫です。今日はいいことがあったんで」

　根津はカップを受け取り、奥のミルに豆を入れた。ガリガリという音。蓮の画面では、緑のチェックマークがまだ点灯している。

「根津さん」

「ん」

「もう少ししたら、見せたいものがあります」

　根津の手が一瞬止まった。それから何事もなかったようにミルを回した。

「コーヒーより美味いもんなら、いつでも見せてくれ」

　蓮は笑った。コーヒーよりは美味くないかもしれない。でも、コーヒーと同じくらい、毎日のなかに溶け込めるものにしたい。

　テストネットの決済完了画面を閉じ、蓮は残り二日間のタスクリストを開いた。エラーハンドリングの強化。有効期限切れ時のUI。ネットワークエラーへの対応。まだやることはある。

　でもコードは、動いた。

　蓮のコードが、ブロックチェーンの上を走った。

　あと二日。根津の前で「ピッ」と鳴らすまで、あと二日だ。

---

　十四日目の夜。

　蓮は丘部にメッセージを送った。

> プロトタイプが完成しました。テストネットで動作確認済みです。
>
> 店舗側：金額入力 → QRコード生成 → 決済完了通知
> 客側　：QRスキャン → ウォレット接続 → J-Coin送金
>
> ノンスによる二重支払い防止、5分間の有効期限、トランザクション検証、すべて実装しました。
>
> 根津さんに見せる準備ができています。

　返信は一分で来た。

> 丘部：やったね。来週、白石と一緒にねづ珈琲に行く。日程は任せる。
>
> それと一つ。根津さんには「ブロックチェーン」とも「ステーブルコイン」とも言うな。僕らが話す。君はただ、アプリを動かして見せろ。

　蓮はスマートフォンをデスクに置き、天井を見上げた。

　二週間前、このデスクで`create-next-app`を叩いたときは、完成する保証などなかった。ブロックチェーン歴一週間の人間がQRコード決済アプリを作る。冷静に考えれば無謀だった。

　でも作れた。

　一人で作ったわけではない。RainbowKitとWagmiが、ウォレット接続の複雑さを吸収してくれた。Prismaが、データベースの型安全性を保証してくれた。美華が、Wagmiのフックの使い方を教えてくれた。kirishi_maが、設計思想を示してくれた。丘部が、走る方向を照らしてくれた。

　蓮が書いたのは、それらすべてを一本の線でつなぐコードだ。SDKの上に、ライブラリの上に、コミュニティの知恵の上に、蓮自身の三年間のWebエンジニアリング経験を載せて、「根津がピッと鳴らせる箱」を組み上げた。

　エコシステムとは、こういうことだ。

　誰かが敷いたレールの上を、自分の足で走る。走りながら見つけた道を、次の誰かに共有する。蓮がこのアプリのコードを公開すれば、別の商店街の、別のエンジニアが、同じような——でも少し違う——決済アプリを作るかもしれない。その人がまた、別の問題を見つけて、別の解き方をする。

　コードは循環する。プロトコルは循環する。

　蓮はMacBookを閉じ、明日の準備を始めた。根津のためにデモ用のタブレットを借りる。テストネットのトークンを補充する。QRコードが紙に印刷されたときの読み取り精度も確認しておく。

　来週、根津の前に立つ。丘部と白石が隣にいてくれる。

　でも「ピッ」と鳴らすのは、蓮のコードだ。

　三百三十六時間前、カレンダーアプリに入力した期限。その数字がゼロになる日が来た。ゼロになったのに、終わった気がしない。むしろ、ここから始まる気がしている。

　プロトタイプは完成した。しかしプロトタイプは、最初の一歩にすぎない。テストネットで動くことと、メインネットで動くことは違う。メインネットで動くことと、根津が毎日使えることは違う。根津が使えることと、商店街全体が受け入れることは、もっと違う。

　蓮は窓の外を見た。深夜の東京。どこかのビルの明かりが瞬いている。あの明かりの下にも、何かを作っている誰かがいるのかもしれない。美華のように。kirishi_maのように。まだ名前も知らない、J-Coinのエコシステムのどこかにいる、まだ走り始めていない誰か。

　蓮は明かりを消した。明日に備えて眠る。根津のコーヒーの香りが、まだ服に残っていた。
