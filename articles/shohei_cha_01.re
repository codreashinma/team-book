= 第一章　午前一時のコンパイルエラー

== 歯車の悲鳴

午前一時。

雪川翔の部屋は、MacBook Airから放たれる冷たい光だけが支配していた。

壁には貼りっぱなしのNeville Brodyのポスター。八〇年代のロンドンで活版印刷の常識を叩き壊し、グラフィックデザインという概念そのものを再定義した伝説のデザイナー。その先鋭的なタイポグラフィが、薄暗い六畳の壁でこちらを見下ろしている。お前は何を壊した？　何を作った？　そう問いかけてくるかのように。

床には読みかけのデザイン雑誌が散乱し、翔の心の混沌を映し出しているかのようだった。『AXIS』の最新号が開きっぱなしで、その上に『+DESIGNING』が無造作に重なっている。どちらも、買ったときは胸が高鳴ったはずだ。いまは、ただの紙の山にしか見えない。

雪川翔は二十八歳。グラフィックデザイン制作会社のアシスタントデザイナーとして三年が過ぎた。

三年。

その数字を頭の中で転がすと、不思議なほど軽い。何も残していないから軽いのだと、翔は気づいていた。

毎朝九時半に出社し、ディレクターから降りてきた指示書を開き、クライアントの要望と上司のフィードバックの間で、デザインデータの色味を微調整する。CMYKのK値を2%下げろ。このフォントはゴシックじゃなくて明朝にしてくれ。ロゴの位置を3ミリ右にずらして。そんな指示を、一日に何十回と繰り返す。

創造性という言葉は、入社時に抱いていた輝きを失い、ただの作業指示に成り下がっていた。

「……これで、いいのか？」

吐き出した息が、白く濁ってモニターに反射する。十一月の東京。暖房をつける気力すら残っていなかった。

翔はAdobe Illustratorの画面を見つめた。クライアントから戻ってきた修正依頼は今日で七回目。「もう少しポップに」「やっぱり落ち着いた感じで」「最初の案の方向性で、でも色は変えて」。堂々巡りの修正地獄。しかもこのデザインには翔の名前は載らない。アシスタントとは、そういうことだ。

デザイン事務所に就職したとき、翔は信じていた。いつか自分のデザインが世に出る。自分の名前で仕事ができるようになる。三年経って理解したのは、アシスタントから上がれるのはほんの一握りで、大半は消耗しきって業界を去るか、あるいは永遠にアシスタントのまま歳を重ねるかのどちらかだという現実だった。

翔はIllustratorを閉じ、ブラウザを開いた。特に見たいものがあるわけではない。ただ、この息苦しさから一瞬でも逃れたかった。

何か、自分の意志で、ゼロから形あるものを生み出したい。

そんな渇望が、息苦しさとなって喉元までせり上がってくる。

翔はブックマークバーに並んだサイトを眺めた。Behance、Dribbble、Pinterest——デザイナーなら誰でも見るポートフォリオサイトたち。でも今夜、翔の指はそのどれもクリックしなかった。

代わりに、ブラウザの検索バーに指を置いた。何を検索すればいいかもわからない。ただ、漠然とした焦燥感だけが指先を震わせている。

ふと、数週間前の記憶がフラッシュバックした。

渋谷のコワーキングスペースで見た、あの画面。黒い背景に、カラフルなコードが整然と並んでいた光景。あの二人が、たった一週間で「アプリ」を作り上げてしまった、あの夜のことを。


== 六本木、午後八時

話は三週間前に遡る。

翔が言語交換ミートアップに参加したのは、正直に言えば、英語力を上げたかったからではなかった。

仕事以外の人間と話したかっただけだ。

会社のデザイナーたちとの会話は、いつもクライアントの愚痴か、Adobeソフトの新機能の話か、あるいは昨日のテレビの話題で終わる。もちろん嫌いではない。でも、その円環の中にいると、自分の世界がどんどん小さくなっていく気がした。

六本木の雑居ビルの三階。「Language Exchange Tokyo」と書かれた看板の先にある、バーを借り切った会場には、三十人ほどが集まっていた。日本語を学びたい外国人と、英語を練習したい日本人が、ビール片手に会話する。翔は壁際でハイボールを飲みながら、なかなか輪に入れずにいた。

「あの、日本の方ですか？」

声をかけてきたのは、翔と同い年くらいの男だった。黒のパーカーにジーンズ。首からAirPodsをぶら下げ、手にはiPhoneではなくAndroid端末を持っている。テック系の人間だと、直感的にわかった。

「はい。柏木です。グラフィックデザイナーをしています」

「中野です。中野健太。モバイルエンジニアやってます。タクシー配車アプリの会社で」

モバイルエンジニア。翔にとっては、名刺交換のときに見かける肩書の一つでしかなかった。ウェブサイトを作るのがウェブエンジニアで、アプリを作るのがモバイルエンジニアなのだろう、くらいのざっくりした認識。

「グラフィックデザイナーですか！」

中野の目が輝いた。翔が思わず半歩引くほどの食いつきだった。

「いや、実はめちゃくちゃデザイナーさん探してたんですよ。俺、個人で開発してるアプリがあって。でもデザインが壊滅的で……。UIを触ってくれる人がいたら最高なんですけど」

UI。ユーザーインターフェース。その言葉なら翔も知っている。ウェブサイトやアプリの見た目を設計すること。デザイン会社でもUI案件は時々入ってくるが、翔が担当するのは主にバナーやチラシなどの印刷物だった。

「個人で、アプリを作ってるんですか？」

「そうそう。もう一人、エンジニアの知り合いがいて、二人で作ってるんだけど」

中野は画面をこちらに向けた。Androidの端末に映っていたのは、メッセージアプリのような画面だった。吹き出し型のチャットUI、プロフィールアイコン、送信ボタン。一見すると、LINEやWhatsAppのような見た目だ。ただし、デザインは——率直に言って洗練されているとは言い難かった。

「名前は『Ignore』っていうんだけど」

「Ignore？　無視、ですか？」

「そう。既読スルーを肯定するSNSっていうコンセプトで。既読つけても返信しなくていい、ってのを全面に打ち出してる。返信のプレッシャーから解放されるメッセージアプリ」

翔は思わず笑った。ばかげている。でも、妙に心に刺さるコンセプトだった。既読スルーの罪悪感は、現代人なら誰しもが抱えている小さな棘だ。

「面白いですね、それ」

「でしょ？　で、来週の土曜日、渋谷のコワーキングスペースでもくもく会やるんだけど、来ない？　デザイン周りを見てもらえるとめちゃくちゃ助かる」

もくもく会。聞いたことはある。各自が自分の作業を黙々と進める集まりのこと。デザイン業界にも似たような勉強会があるが、翔は参加したことがなかった。

断る理由がなかった。というより、会社と自宅の往復以外の予定が入ること自体が、翔にとっては珍しいことだったのだ。

「行きます」

その一言が、雪川翔の人生の分岐点だったと、後になって気づくことになる。


== 二人で作ったSNSアプリ

土曜日、午後一時。渋谷のコワーキングスペースは、カフェのような雰囲気だった。

木のテーブルにMacBookが並び、観葉植物が窓辺に置かれ、BGMにローファイ・ヒップホップが流れている。翔がイメージしていた「エンジニアの作業場」——薄暗い部屋にモニターが三台並んでいるような——とはまるで違った。

「おう、柏木くん！　来てくれたんだ」

中野はすでにテーブルの一角を陣取っていた。MacBook Proの画面には、黒い背景にカラフルな文字が並んでいる。あとで知ったことだが、これが@<b>{Xcode}——AppleのiOSアプリ開発用の統合開発環境だった。

その隣に、もう一人。

「藤原です。美咲。よろしくね」

藤原美咲は翔より少し年上に見えた。肩までの黒髪をひとまとめにし、眼鏡の奥から鋭い目でMacBookの画面を見つめている。後で聞けば、国内有数のモバイルゲーム会社でエンジニアとして働いているらしい。しかも、App Storeのゲームランキングで上位に入るようなタイトルの開発チームに所属しているという。

「柏木さんはグラフィックデザイナーなんだって？」と美咲が言った。「Ignoreのアイコン、作ってもらえると嬉しいな。いま仮でフリー素材使ってるんだけど、やっぱりちゃんとしたのが欲しくて」

「もちろん。それくらいなら」

翔はMacBook Airを開き、Illustratorを起動した。アイコン制作なら、翔の専門だ。Ignoreのコンセプトを聞き、シンプルな吹き出しマークに「×」を組み合わせたアイコンを三案ほどスケッチした。

その間、中野と美咲はXcodeの画面に向かっていた。

時折、二人の会話が耳に入る。

「ここ、@<code>{NavigationStack}にした方がよくない？　@<code>{NavigationView}はもうdeprecatedだし」

「いいね。あと、メッセージ一覧のセルは@<code>{LazyVStack}にしよう。パフォーマンス的に@<code>{List}よりいい場合がある」

「@<code>{@StateObject}と@<code>{@ObservedObject}、どっち使う？　ここのViewModelは親Viewで生成してるから——」

「@<code>{@StateObject}は生成元で使って、子に渡すときは@<code>{@ObservedObject}ね」

翔にはほとんど理解できなかった。

NavigationStack？　LazyVStack？　StateObject？　それはデザインツールの機能名ではない。プログラミング言語の用語だ。しかも、二人は流れるように会話し、画面上のコードを書き換え、瞬時にiPhoneの画面のようなものをMac上に表示させている。

@<b>{シミュレータ}——Mac上でiPhoneの動作を再現するツールだと、後で教えてもらった。

翔がアイコンを三案仕上げるのに二時間かかった。その間に、中野と美咲はチャット画面のリアルタイム更新機能を実装し終えていた。

「えっと……これ、いつから作ってるんですか？」

翔が恐る恐る聞くと、中野が軽い調子で答えた。

「先週の月曜からだから、ちょうど一週間かな」

一週間。

たった一週間で、メッセージの送受信ができて、プロフィールが設定できて、チャットルームを作成できるSNSアプリが形になっている。翔がこの一週間で作ったのは、化粧品ブランドのパンフレットの色校正と、飲食店のメニュー表の修正データだった。

衝撃、という言葉では足りなかった。

「中野さん、これ……何で作ってるんですか？」

「Swiftっていうプログラミング言語。で、UIの部分はSwiftUIっていうフレームワーク。Appleが公式で出してる」

@<b>{Swift}。@<b>{SwiftUI}。

翔はその名前を、スマートフォンのメモ帳に書き留めた。

「SwiftUIいいよ」と美咲が画面から目を離さずに言った。「UIをコードで宣言的に書けるの。デザイナーさんなら、むしろ直感的かもしれない。『ここにテキストを置いて、その下に画像を置いて、横並びにして』みたいに、レイアウトの構造がそのままコードになるから」

宣言的。その言葉の意味はまだわからなかったが、「レイアウトの構造がそのままコードになる」という部分は、デザイナーの翔の心に強く引っかかった。

Illustratorでレイアウトを組むとき、翔は常に「この要素はここ、あの要素はあそこ」と配置を考える。それがコードとして書ける？

帰り際、翔はもう一度、シミュレータに映るIgnoreの画面を見つめた。中野と美咲が書いたコードが、iPhoneの形をしたウィンドウの中で動いている。自分がデザインしたアイコンが、そのアプリの顔として左上に鎮座している。

たった一日で、自分のデザインが「動くプロダクト」の一部になった。

印刷物では、この感覚は得られない。バナーもチラシもパンフレットも、完成した瞬間から静止する。でもアプリは違う。タップすれば反応し、スクロールすれば動き、データが流れ込んで画面が変わる。

翔のMacBook Airには、XcodeもSwiftもインストールされていない。翔にできたのは、アイコンを作ることだけだった。その事実が、無力感と同時に、これまで感じたことのない強烈な@<b>{憧れ}として胸の奥に刻まれた。


== Xcodeという名の扉

午前一時。三週間前の記憶から引き戻された翔は、MacBook Airの画面を見つめていた。

ブラウザの検索バーには、いつの間にか文字が入力されていた。

@<b>{「Xcode　ダウンロード」}

心臓が跳ねた。自分の指が、自分の意志を先回りしたかのようだった。

AppleのDeveloperページを開く。Xcodeの容量表示を見て、翔は目を疑った。

@<b>{約10GB。}

自分のMacBook Airのストレージ残量を確認すると、ぎりぎりだった。不要なファイルを削除し、使っていないアプリをアンインストールし、なんとかスペースを確保する。ダウンロードの進捗バーが、気が遠くなるほどゆっくりと進んでいく。

三十分後、Xcodeのインストールが完了した。

アイコンをクリックする。水色のハンマーを模したアイコンが、Dockの上で弾むように跳ねた。

起動画面が表示される。@<b>{Welcome to Xcode}。

「Create New Project」をクリックする。テンプレート選択画面が現れた。App、Document App、Game、Augmented Reality App——。選択肢の多さに、翔は一瞬たじろいだ。おそらく「App」を選べばいいのだろう。

Product Name:に何と入れればいいのか。迷った末に「MyFirstApp」と入力した。

Interfaceの選択肢に「SwiftUI」と「Storyboard」がある。美咲が言っていた。SwiftUIはAppleが推している新しいフレームワークだと。迷わずSwiftUIを選んだ。

Languageは「Swift」一択。

Createを押す。

画面が一変した。

左側にフォルダ構造が表示され、中央にはコードエディタ、右側にはiPhoneの画面を模したプレビューが並んでいる。コードエディタには、すでに何かが書かれていた。

//list[first_contentview][最初に表示されるContentView.swift][swift]{
import SwiftUI

struct ContentView: View {
    var body: some View {
        VStack {
            Image(systemName: "globe")
                .imageScale(.large)
                .foregroundStyle(.tint)
            Text("Hello, World!")
        }
        .padding()
    }
}
//}

翔はこのコードを、一行ずつ読もうとした。

@<code>{import SwiftUI}——SwiftUIを使いますよ、という宣言だろう。Illustratorでプラグインを読み込むのと似たようなものか。

@<code>{struct ContentView: View}——ContentViewという名前のViewを定義している。Viewとは、画面に表示される要素のことだろう。

@<code>{var body: some View}——このViewの中身を定義する場所。bodyと書いてあるから、Viewの「本体」ということか。

@<code>{VStack}——中野と美咲の会話に出てきた単語だ。Verticalのスタック。縦に積み重ねる、という意味だろう。つまり、この中括弧の中にある要素が上から下に並ぶ。

@<code>{Image(systemName: "globe")}——地球儀のアイコンを表示している。

@<code>{Text("Hello, World!")}——テキストを表示している。

翔は自分でも驚くほど、素直にコードを読めている気がした。

美咲が言った通りだ。@<b>{レイアウトの構造が、そのままコードになっている。}

「VStackの中に、Imageがあって、その下にTextがある」——これは、Illustratorで「上に画像を置いて、下にテキストを置く」と考えるのとまったく同じ構造ではないか。

翔はキーボードに手を置いた。@<code>{Text("Hello, World!")}の文字列を書き換えてみる。

//list[first_edit][最初の編集][swift]{
Text("こんにちは、世界。雪川翔、28歳。")
//}

右側のプレビューが、即座に更新された。iPhoneの画面に「こんにちは、世界。雪川翔、28歳。」という文字が表示されている。

翔の心臓が、もう一度跳ねた。

たった数文字を変えただけで、画面が変わった。IllustratorやPhotoshopでテキストを変更するのと何が違う？　いや、違う。決定的に違う。

これはデザインデータではない。@<b>{アプリ}だ。

翔の指が、もう止まらなくなっていた。

//list[experiment][実験的なコード変更][swift]{
struct ContentView: View {
    var body: some View {
        VStack {
            Image(systemName: "heart.fill")
                .imageScale(.large)
                .foregroundStyle(.red)
            Text("こんにちは、世界。雪川翔、28歳。")
                .font(.title)
                .fontWeight(.bold)
            Text("グラフィックデザイナー → ???")
                .font(.subheadline)
                .foregroundStyle(.gray)
        }
        .padding()
    }
}
//}

地球儀のアイコンをハートに変え、色を赤にした。テキストにフォントサイズと太さを指定した。二行目のテキストを追加し、サブヘッドラインのサイズでグレーにした。

@<code>{.font(.title)}、@<code>{.fontWeight(.bold)}、@<code>{.foregroundStyle(.gray)}。

これらは@<b>{モディファイア}と呼ばれるもので、Viewに対して装飾を「連鎖的に」適用する仕組みだった。CSSのプロパティに近い——いや、むしろデザインソフトの「効果を重ねがけする」感覚に近い。

プレビューには、赤いハートの下に太字のテキスト、その下にグレーのサブテキストが表示されている。

翔は時計を見た。午前二時四十五分。

いつの間にか二時間近く経過していた。


== Landmarksという名の教科書

翌日の日曜日、翔は朝から検索を続けていた。

「SwiftUI　初心者　学習」「SwiftUI　チュートリアル　日本語」「iPhone　アプリ開発　始め方」——。

さまざまなブログ記事や動画が出てきたが、情報の鮮度がバラバラで、何から手をつければいいかわからない。SwiftUIは二〇一九年に発表された比較的新しいフレームワークで、毎年のようにアップデートされているため、古い記事の情報はそのまま使えないことがある。

そんな中、翔はあるページにたどり着いた。

@<b>{Apple公式のSwiftUIチュートリアル——「Introducing SwiftUI」。}

Appleが自ら用意した、SwiftUIの学習教材。サンプルプロジェクトとして「Landmarks」というアプリを段階的に作っていくチュートリアルだ。公式が出しているのだから、これが最も正確な情報源のはずだ。

翔はチュートリアルを開いた。英語だった。技術英語は翻訳ツールを使いながら読み進めることにした。

最初のセクションで、TextとImageの使い方を学ぶ。

//list[landmarks_text][Landmarksチュートリアル：テキストの表示][swift]{
Text("Turtle Rock")
    .font(.title)
Text("Joshua Tree National Park")
    .font(.subheadline)
Text("California")
//}

次に、レイアウトの組み合わせを学ぶ。@<code>{VStack}は縦に並べる。@<code>{HStack}は横に並べる。@<code>{Spacer}は余白を作る。

//list[landmarks_layout][Landmarksチュートリアル：レイアウトの組み合わせ][swift]{
VStack(alignment: .leading) {
    Text("Turtle Rock")
        .font(.title)
    HStack {
        Text("Joshua Tree National Park")
            .font(.subheadline)
        Spacer()
        Text("California")
            .font(.subheadline)
    }
}
.padding()
//}

翔の目が輝いた。

@<code>{VStack(alignment: .leading)}——「左揃えで縦に積む」。これは、Illustratorの整列パネルで「左揃え」を選択するのとまったく同じ概念だ。

@<code>{HStack}の中にテキストが二つあり、間に@<code>{Spacer()}がある。つまり「左にテキスト、右にテキスト、間は余白で埋める」。デザイナーが日常的にやっているレイアウト操作を、コードで表現しているだけだ。

//note[SwiftUIの基本レイアウト]{
SwiftUIのレイアウトは三つの基本スタックで構成される。

@<b>{VStack}：子要素を@<b>{縦}（Vertical）に並べる。上から下に要素が積まれる。

@<b>{HStack}：子要素を@<b>{横}（Horizontal）に並べる。左から右に要素が並ぶ。

@<b>{ZStack}：子要素を@<b>{奥行き}方向に重ねる。背景の上に前景を重ねるときに使う。

デザインツールでいえば、VStackは「縦方向の自動レイアウト」、HStackは「横方向の自動レイアウト」、ZStackは「レイヤーの重なり」に相当する。
//}

チュートリアルが進む。画像を円形にクリッピングする方法を学ぶ。

//list[landmarks_circle][Landmarksチュートリアル：円形画像][swift]{
Image("turtlerock")
    .clipShape(Circle())
    .overlay {
        Circle().stroke(.white, lineWidth: 4)
    }
    .shadow(radius: 7)
//}

@<code>{.clipShape(Circle())}で画像を円形にクリッピングし、@<code>{.overlay}で白い枠線を重ね、@<code>{.shadow}でドロップシャドウを付ける。翔はPhotoshopでまったく同じ処理をしたことが何十回もある。レイヤーマスクで円形に切り抜き、レイヤースタイルで境界線を追加し、ドロップシャドウを適用する。あの手順が、たった四行のコードで完結する。

「すごいな……」

翔は独り言を言い、すぐに苦笑した。デザイナーが「コードが美しい」と思うなんて、三週間前の自分には想像もできなかった。

チュートリアルはさらに続く。@<code>{MapKit}を使って地図を表示する方法。@<code>{List}を使って一覧画面を作る方法。@<code>{NavigationStack}で画面遷移を実装する方法。

//list[landmarks_list][Landmarksチュートリアル：リスト表示と画面遷移][swift]{
NavigationStack {
    List(landmarks) { landmark in
        NavigationLink {
            LandmarkDetail(landmark: landmark)
        } label: {
            LandmarkRow(landmark: landmark)
        }
    }
    .navigationTitle("Landmarks")
}
//}

@<code>{List}——データの一覧を表示するコンポーネント。iPhoneの設定画面のような、行が縦に並ぶUIを自動的に生成してくれる。

@<code>{NavigationLink}——タップしたら別の画面に遷移するリンク。ウェブサイトのハイパーリンクのようなものだ。

@<code>{NavigationStack}——画面遷移を管理する親要素。画面を「積み重ねて」いき、戻るボタンで一つずつ戻る。iPhoneユーザーなら日常的に体験している「設定 → Wi-Fi → ネットワーク詳細」のような階層構造を、このコードが実現している。

翔は土日をほぼすべてチュートリアルに費やした。月曜日の朝、出社前にも三十分だけ触った。火曜日の夜も、水曜日の昼休みも。

Landmarksチュートリアルは全七章。翔は一週間かけて、第五章まで進んだ。

そこで、壁にぶつかった。


== エラーの壁

第五章。アニメーションとトランジションを実装するセクションで、翔のXcodeが赤く染まった。

//quote{
Type 'HikeView' does not conform to protocol 'View'
//}

赤い丸に白い「×」。エラーマークがコードの左側に表示されている。

翔は何が起きたのか理解できなかった。チュートリアルの通りにコードを書いたはずだ。一文字ずつ、丁寧に。しかし、Xcodeは無慈悲にエラーを吐き続ける。

別のエラーも出ていた。

//quote{
Cannot convert value of type 'Bool' to expected argument type 'Binding<Bool>'
//}

@<code>{Bool}を@<code>{Binding<Bool>}に変換できない？

翔はまずGoogle検索を試みた。エラーメッセージをそのまま貼り付ける。英語の検索結果が並ぶ。Stack Overflowというサイトが頻繁にヒットした。プログラマーの質疑応答サイトらしい。

回答を読むが、「@<code>{@Binding}を使ってください」としか書かれていない。@<code>{@Binding}とは何か。チュートリアルにも登場していたが、翔の理解が追いついていなかった。

@<code>{@State}は前のセクションで学んだ。Viewの内部で状態を管理するための仕組みだ。たとえばトグルのオン・オフを@<code>{@State}で管理する。

//list[state_example][@Stateの基本的な使い方][swift]{
struct ToggleView: View {
    @State private var isOn = false

    var body: some View {
        Toggle("設定を有効にする", isOn: $isOn)
    }
}
//}

@<code>{$isOn}——変数名の前に@<code>{$}を付けると、@<code>{Binding}になるらしい。しかし、なぜBindingが必要なのか。なぜ単なるBoolではだめなのか。翔の頭の中はIllustratorのベクターパスのように複雑に絡まっていた。

三時間が経った。

四時間。

五時間。

コードを書き直しては消し、消しては書き直す。エラーは消えるどころか増えている。一つのエラーを修正すると、別の場所で新しいエラーが発生する。モグラ叩きのようだ。

午前三時。翔は椅子の背にもたれかかり、天井を見上げた。

Neville Brodyが見下ろしている。

翔は唇を噛んだ。デザインツールなら、何時間でも戦える。Illustratorのペンツールで思い通りの曲線が引けなくても、何度でもやり直せる。それは「技術の習熟」であり、反復が確実に成果に結びつく。しかしプログラミングのエラーは違う。コードが正しいか間違っているか、0か1かの世界。99%合っていても、残り1%が間違っていれば動かない。

これが、デザイナーとエンジニアの世界の違いなのか。

翔は諦めかけていた。やはり自分にはプログラミングは向いていないのではないか。デザインの世界に戻るべきではないか。

だが、一つだけ、試していないことがあった。


== 一四〇文字の叫び

翔はXを開いた。

普段はデザイン系のアカウントを眺めるだけの閲覧専用アカウント。フォロワーは三十人もいない。投稿したのは半年以上前が最後だ。

それでも、翔はポストの作成画面を開いた。

//quote{
SwiftUI初心者です。Apple公式のLandmarksチュートリアルをやっていますが、@Stateと@Bindingの使い分けでエラーが出て5時間解決できません。「Cannot convert value of type 'Bool' to expected argument type 'Binding<Bool>'」誰か助けてください…

#SwiftUI #iOSdev #プログラミング初学者
//}

投稿した瞬間、翔は後悔した。こんな初歩的な質問を公の場に晒して、笑われるのではないか。「ググれ」と言われるのではないか。

しかし、十五分後。通知が来た。

@<b>{志村 @shimura_ios}

//quote{
@kashiwagi_ren はじめまして！5時間お疲れさまです。@Stateと@Bindingで詰まるの、あるあるですよ。

簡単に説明すると：
・@Stateは「自分で値を持っているView」で使う
・@Bindingは「親Viewから値を受け取るView」で使う

$マークを付けるとStateがBindingに変換されます。エラーのコード、もし共有できたらもう少し具体的にアドバイスできます！
//}

翔は目を疑った。深夜三時に、見ず知らずの人間が丁寧に回答してくれている。

志村——プロフィールを見ると、iOS歴十年のシニアエンジニアで、技術書の執筆もしているらしい。フォロワーは数千人。なぜそんな人が、フォロワー三十人の初心者の叫びに反応してくれたのか。

翔は震える手でコードのスクリーンショットを撮り、リプライした。

五分後、志村から再びリプライが届いた。

//quote{
なるほど、これは子Viewに値を渡すところですね。

親Viewで@Stateとして宣言した変数を、子Viewでは@Bindingで受け取ります。こう考えてください：

・@Stateは「原本」。データの持ち主。
・@Bindingは「参照」。原本を指し示すリンク。

親から子にデータを渡すときは、$を付けてBindingとして渡す。子View側では@Bindingで受け取る。これで親と子のデータが常に同期されます。
//}

翔の頭の中で、パズルのピースがはまる音がした。

@<b>{原本と参照。}

デザインの世界で言えば——Illustratorの「シンボル」に似ている。シンボルの原本を編集すれば、それを参照しているすべてのインスタンスが自動的に更新される。@<code>{@State}が原本で、@<code>{@Binding}がインスタンス。原本を変更すれば、参照先も変わる。

//list[binding_example][@Stateと@Bindingの関係][swift]{
// 親View：@Stateで「原本」を持つ
struct ParentView: View {
    @State private var isShowingDetail = false

    var body: some View {
        VStack {
            // $を付けてBindingとして子に渡す
            ChildView(isShowing: $isShowingDetail)
            Text(isShowingDetail ? "表示中" : "非表示")
        }
    }
}

// 子View：@Bindingで「参照」を受け取る
struct ChildView: View {
    @Binding var isShowing: Bool

    var body: some View {
        Toggle("詳細を表示", isOn: $isShowing)
    }
}
//}

翔はコードを書き直した。チュートリアルのHikeViewに、正しく@<code>{@Binding}を設定する。ビルドボタンを押す。

エラーが消えた。

プレビュー画面に、アニメーション付きのグラフが表示された。ハイキングの標高データがなめらかに動いている。

「っしゃ……！」

翔は小さくガッツポーズをした。午前四時。窓の外はまだ暗いが、翔の心の中には確かに光が差していた。

//note[Stateの仕組み：プロパティラッパーとは]{
SwiftUIにおける@<code>{@State}、@<code>{@Binding}、@<code>{@ObservedObject}などは@<b>{プロパティラッパー}と呼ばれる仕組みだ。

変数の前に@<code>{@State}を付けると、SwiftUIがその変数の変更を監視し、値が変わったときに自動的にUIを再描画する。通常の@<code>{var}では、値を変更してもUIには反映されない。

プロパティラッパーの主な種類：
 * @<code>{@State}：View内部のプライベートな状態管理。そのViewだけが所有するデータ。
 * @<code>{@Binding}：親Viewから渡されたデータへの参照。双方向にデータが同期される。
 * @<code>{@StateObject}：ObservableObjectプロトコルに準拠したオブジェクトを生成・保持する。
 * @<code>{@ObservedObject}：外部から渡されたObservableObjectを監視する。
 * @<code>{@EnvironmentObject}：アプリ全体で共有するデータを注入する。

初心者がまず理解すべきは@<code>{@State}と@<code>{@Binding}の関係だ。この二つがSwiftUIのデータフローの基礎となる。
//}

志村にお礼のリプライを送ると、思いがけない返事が来た。

//quote{
解決してよかったです！学習続けるなら、YouTubeの「Swiftful Thinking」っていうチャンネルがおすすめですよ。英語ですけど、コードを見ながら手を動かすスタイルなので、言語の壁は意外と低いです。SwiftUIの基礎から体系的に学べます。

あと、Xで学習の進捗を投稿し続けるといいですよ。同じように学んでいる人とつながれるし、アウトプットすると記憶に定着しやすいので。応援してます！
//}

翔は、自分の目頭が熱くなるのを感じた。

プログラミングの世界は冷たいものだと思っていた。「ググれカス」という言葉がネットスラングとして存在するくらいだ。しかし現実は違った。深夜三時に、見ず知らずの初心者に、丁寧に、親切に教えてくれる人がいる。

この世界には、手を差し伸べてくれる人がいる。

翔はXのプロフィールを更新した。

//quote{
雪川翔｜グラフィックデザイナー → iOSアプリ開発勉強中｜SwiftUI学習記録
//}


== Swiftful Thinking

志村に勧められた「Swiftful Thinking」のYouTubeチャンネルを開いたのは、翌日の昼休みだった。

会社のデスクで、イヤホンを片耳だけ装着して再生する。

チャンネル運営者のNickは、落ち着いたトーンで一つずつ丁寧にコードを書きながら説明していく。英語だが、画面に映るXcodeのコードが共通言語として機能する。@<code>{Text}、@<code>{Image}、@<code>{Button}、@<code>{List}——SwiftUIのコンポーネント名は英語そのものだから、コードを見れば何をしているかは大体わかる。

翔はまず「SwiftUI Bootcamp」というプレイリストから視聴を始めた。

第一回はTextの使い方。

//list[swiftful_text][Swiftful Thinking: Textのカスタマイズ][swift]{
Text("Hello, World!")
    .font(.title)           // フォントサイズ
    .fontWeight(.semibold)   // フォントの太さ
    .foregroundStyle(.red)   // テキストの色
    .underline(true, color: .red)  // 下線
    .italic()               // イタリック
    .strikethrough(true, color: .gray) // 取り消し線
    .multilineTextAlignment(.center)   // 複数行の配置
    .frame(width: 200, height: 100)    // フレームサイズ指定
    .minimumScaleFactor(0.1) // テキスト縮小の最小比率
//}

翔はデザイナーとして即座に理解した。これはCSSのテキストプロパティと同じだ——いや、もっと直感的だ。@<code>{.font(.title)}と書けばタイトルサイズになる。@<code>{.foregroundStyle(.red)}で赤くなる。@<code>{.italic()}でイタリック体になる。

一つ一つのモディファイアが、デザインソフトのプロパティパネルの項目に対応している。

次に学んだのはButtonだ。

//list[swiftful_button][Swiftful Thinking: Buttonの基本][swift]{
Button {
    // ボタンが押されたときの処理
    print("ボタンが押されました")
} label: {
    Text("押してください")
        .font(.headline)
        .foregroundStyle(.white)
        .padding()
        .background(Color.blue)
        .cornerRadius(10)
}
//}

@<code>{Button}には二つの部分がある。@<code>{action}（押されたときに何をするか）と@<code>{label}（ボタンの見た目）。見た目の部分は、これまで学んだTextやImageと同じようにモディファイアで装飾できる。

翔は動画を一時停止し、自分のXcodeで同じコードを書いてみた。プレビューに青い角丸のボタンが表示される。タップすると——プレビュー上ではわからないが、コンソールに「ボタンが押されました」と出力される。

@<b>{動く。自分が書いたコードが、ちゃんと動く。}

次にShapeとColor。

//list[swiftful_shape][Swiftful Thinking: 図形と色][swift]{
ZStack {
    // 背景のグラデーション
    LinearGradient(
        colors: [.blue, .purple],
        startPoint: .topLeading,
        endPoint: .bottomTrailing
    )
    .ignoresSafeArea()

    // 前面の円
    Circle()
        .fill(.white.opacity(0.3))
        .frame(width: 200, height: 200)
        .shadow(color: .black.opacity(0.3), radius: 10, x: 0, y: 5)
}
//}

グラデーション。円形。透明度。シャドウ。すべてデザイナーが日常的に扱う要素だ。しかし、これがコード数行で表現できる。

翔はZStackの仕組みを理解した。@<code>{ZStack}はレイヤーの重なりだ。Illustratorでいう「前面に配置」「背面に配置」と同じ。ZStackの中に書いた順に、下から上にレイヤーが積まれる。最初に書いたものが最背面、最後に書いたものが最前面。

昼休みの四十五分では足りなかった。翔は帰宅後、毎晩二時間をSwiftful Thinkingの視聴に充てた。通勤の電車内でもイヤホンで視聴した。

一週間で、以下のコンポーネントを学んだ。

 * @<code>{Text}：テキスト表示
 * @<code>{Image}：画像・アイコン表示（SF Symbolsを含む）
 * @<code>{Button}：タップ可能なボタン
 * @<code>{TextField}：テキスト入力フィールド
 * @<code>{Toggle}：オン/オフスイッチ
 * @<code>{Slider}：スライダー
 * @<code>{List}：データ一覧表示
 * @<code>{NavigationStack}：画面遷移の管理
 * @<code>{Sheet}：モーダル表示
 * @<code>{Alert}：アラートダイアログ
 * @<code>{ScrollView}：スクロール可能な領域

そしてレイアウト系の基礎として、@<code>{VStack}、@<code>{HStack}、@<code>{ZStack}、@<code>{Spacer}、@<code>{padding}、@<code>{frame}。

デザイナーの翔にとって、SwiftUIのコンポーネントはデザインツールのパーツパレットに見えた。Illustratorのツールバーに並ぶ長方形ツール、楕円ツール、テキストツールと同じように、SwiftUIにも用途ごとのコンポーネントがある。違うのは、それが「動く」ということだ。

Xに学習記録を投稿し始めた。

//quote{
Day 5：ScrollViewとListの違いがやっとわかった。ListはデータのForEachに最適化されてて、ScrollViewは自由にレイアウトしたいときに使う。デザイナー的にはScrollViewの方が直感的。 #SwiftUI学習
//}

志村さんがいいねをくれた。他にも、何人かのアカウントからいいねが付いた。同じようにSwiftUIを学んでいる人たちだった。

翔の世界が、少しずつ広がり始めていた。


== 初めての「自分のアプリ」

Swiftful Thinkingの動画を三十本ほど消化し、Apple公式チュートリアルも最後まで完走した頃、翔の中に一つの衝動が芽生えた。

チュートリアルの写経はもう十分だ。@<b>{自分のアプリを作りたい。}

何を作るか。翔は悩んだ。中野と美咲のようにSNSアプリを作る技術は、まだない。地図アプリもまだ早い。初めてのアプリは、シンプルな方がいい。

Todoアプリ。

タスク管理ツールとしてのTodoアプリは、プログラミング学習の「Hello, World!」の次に来る定番プロジェクトだ。データの追加、表示、削除、更新——いわゆるCRUD操作を一通り学べる。

翔はXcodeで新しいプロジェクトを作成した。Product Nameは「MyTodo」。

まず、Todoのデータ構造を考える。デザイナーとして、UIを先に考えるのが翔の自然な発想だった。

「Todoアプリに必要な情報は何だろう」

一つのTodoには、タイトルがある。完了したかどうかのフラグがある。いつ作成されたかの日付もあった方がいい。これをSwiftの@<code>{struct}——構造体で表現する。

//list[todo_model][TodoItem：データモデルの定義][swift]{
struct TodoItem: Identifiable {
    let id = UUID()
    var title: String
    var isCompleted: Bool
    let createdAt: Date

    init(title: String) {
        self.title = title
        self.isCompleted = false
        self.createdAt = Date()
    }
}
//}

@<code>{Identifiable}プロトコルに準拠させることで、SwiftUIの@<code>{List}や@<code>{ForEach}がこのデータを一意に識別できるようになる。@<code>{UUID()}で自動的にユニークなIDが生成される。

翔は志村さんに教わった@<code>{@State}を思い出しながら、メイン画面を作り始めた。

//list[todo_list_view][TodoListView：メイン画面の実装][swift]{
struct TodoListView: View {
    @State private var todos: [TodoItem] = []
    @State private var newTodoTitle = ""
    @State private var showingAddSheet = false

    var body: some View {
        NavigationStack {
            List {
                ForEach(todos) { todo in
                    TodoRowView(todo: todo, onToggle: {
                        toggleTodo(todo)
                    })
                }
                .onDelete(perform: deleteTodo)
            }
            .navigationTitle("My Todo")
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button {
                        showingAddSheet = true
                    } label: {
                        Image(systemName: "plus")
                    }
                }
            }
            .sheet(isPresented: $showingAddSheet) {
                AddTodoView(
                    newTodoTitle: $newTodoTitle,
                    onAdd: addTodo
                )
            }
            .overlay {
                if todos.isEmpty {
                    ContentUnavailableView(
                        "Todoがありません",
                        systemImage: "checklist",
                        description: Text("右上の＋ボタンからTodoを追加しましょう")
                    )
                }
            }
        }
    }

    private func addTodo() {
        guard !newTodoTitle.isEmpty else { return }
        let newTodo = TodoItem(title: newTodoTitle)
        todos.append(newTodo)
        newTodoTitle = ""
        showingAddSheet = false
    }

    private func deleteTodo(at offsets: IndexSet) {
        todos.remove(atOffsets: offsets)
    }

    private func toggleTodo(_ todo: TodoItem) {
        if let index = todos.firstIndex(where: { $0.id == todo.id }) {
            todos[index].isCompleted.toggle()
        }
    }
}
//}

コードを書き進めるうちに、翔は一つの感覚に気づいた。

これは、@<b>{デザインカンプを作る作業に似ている}。

Illustratorでレイアウトを組むとき、まず全体の構造を決め、次にパーツを配置し、最後にスタイルを調整する。SwiftUIのコーディングもまったく同じだ。まず@<code>{NavigationStack}で全体の枠組みを決め、@<code>{List}で一覧のレイアウトを作り、@<code>{ForEach}で個々の行を描画し、モディファイアでスタイルを整える。

次に、個々のTodoの行を表示するコンポーネントを作る。SwiftUIでは、UIの部品を小さなViewに分割するのが定石だ。

//list[todo_row_view][TodoRowView：Todo一行分のView][swift]{
struct TodoRowView: View {
    let todo: TodoItem
    let onToggle: () -> Void

    var body: some View {
        HStack(spacing: 12) {
            Button {
                onToggle()
            } label: {
                Image(systemName: todo.isCompleted
                    ? "checkmark.circle.fill"
                    : "circle")
                    .font(.title2)
                    .foregroundStyle(
                        todo.isCompleted ? .green : .gray
                    )
            }
            .buttonStyle(.plain)

            VStack(alignment: .leading, spacing: 4) {
                Text(todo.title)
                    .strikethrough(todo.isCompleted)
                    .foregroundStyle(
                        todo.isCompleted ? .gray : .primary
                    )
                Text(todo.createdAt, style: .date)
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }

            Spacer()
        }
        .padding(.vertical, 4)
    }
}
//}

完了済みのTodoには取り消し線を引き、テキスト色をグレーにする。チェックマークは緑色に変わる。デザイナーの血が騒ぎ、翔は視覚的なフィードバックにこだわった。

そしてTodo追加画面。@<code>{sheet}で表示するモーダルビューだ。

//list[add_todo_view][AddTodoView：Todo追加画面][swift]{
struct AddTodoView: View {
    @Binding var newTodoTitle: String
    let onAdd: () -> Void
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationStack {
            Form {
                Section("新しいTodo") {
                    TextField("タイトルを入力", text: $newTodoTitle)
                }
            }
            .navigationTitle("Todo追加")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .topBarLeading) {
                    Button("キャンセル") {
                        newTodoTitle = ""
                        dismiss()
                    }
                }
                ToolbarItem(placement: .topBarTrailing) {
                    Button("追加") {
                        onAdd()
                    }
                    .disabled(newTodoTitle.isEmpty)
                    .fontWeight(.bold)
                }
            }
        }
    }
}
//}

ここで翔は@<code>{@Binding}を使った。志村さんに教わったあの概念だ。

AddTodoViewは親Viewから@<code>{newTodoTitle}を@<code>{@Binding}で受け取る。ユーザーがTextFieldに文字を入力すると、その値は@<code>{@Binding}を通じて親Viewの@<code>{@State}にリアルタイムで反映される。原本と参照。あの夜、志村さんが教えてくれた概念が、ここで実践として結実した。

@<code>{@Environment(\.dismiss)}は新しく覚えた仕組みだ。現在のViewを閉じる（シートを下に消す）機能を、SwiftUIの環境値から取得する。Swiftful Thinkingの動画で学んだテクニックだった。

翔はコードを何度も修正し、UIを磨いた。色の選択、フォントサイズ、余白のバランス——ここはデザイナーの腕の見せどころだ。エンジニアが「とりあえず動けばいい」と作るUIとは一線を画する、視覚的に心地よいTodoアプリを目指した。

//note[SwiftUIのデータフロー基礎]{
SwiftUIのデータフローは@<b>{「単一方向データフロー（Unidirectional Data Flow）」}が基本思想だ。

データは親から子へ、一方向に流れる。子が親のデータを変更したい場合は@<code>{@Binding}を使って「参照」を通じて間接的に操作する。

このアーキテクチャにより、データの流れが予測可能になり、バグが発生しにくくなる。

初心者が最初に覚えるべきパターンは三つ：
 1. @<code>{@State} + 直接参照：同一View内でデータを使うとき
 2. @<code>{@State} + @<code>{@Binding}：親子間でデータを共有するとき
 3. @<code>{@StateObject} + @<code>{@ObservedObject}：複雑なデータをViewModelで管理するとき

翔のTodoアプリでは、パターン1と2を使っている。パターン3は、アプリが複雑になったときに必要になる技術だ。
//}


== 午前一時の光

ビルドボタンを押す。

Xcodeの上部に、進捗バーが走る。「Build Succeeded」の文字が表示された。

シミュレータが起動する。iPhone 15 Proの画面が翔のMacBook Airに映し出された。

「My Todo」というタイトルの画面。右上に「＋」ボタン。中央には「Todoがありません」というメッセージとチェックリストのアイコン。

翔は「＋」ボタンをタップした。モーダルが下からスライドして現れる。テキストフィールドに「SwiftUIをもっと学ぶ」と入力。「追加」ボタンを押す。

画面が切り替わる。リストに一行、「SwiftUIをもっと学ぶ」と表示された。左には灰色の空丸アイコン。日付が小さく表示されている。

空丸をタップする。緑色のチェックマークに変わり、テキストに取り消し線が引かれる。

もう一度タップする。チェックマークが消え、テキストが元に戻る。

翔は左にスワイプした。赤い「Delete」ボタンが現れる。タップすると、行がアニメーションとともに消えた。

すべてが、自分の書いたコードの通りに動いている。

翔はしばらく、シミュレータの画面を見つめていた。

このアプリには、クライアントの要望も、上司の指示も、ディレクターのフィードバックもない。色の選択も、フォントの選択も、レイアウトの設計も、すべて翔が決めた。そして、そのデザインが「動く」ものとして目の前に存在している。

これが、@<b>{ゼロから形あるものを生み出す}ということか。

翔はXを開いた。

//quote{
SwiftUI学習を始めて3週間。初めて自分のアプリを作りました。Todoアプリです。基本的なCRUD操作とSheet、Bindingを使っています。まだまだシンプルですが、自分で一から作ったアプリがシミュレータで動いた瞬間の感動は言葉にできません。 #SwiftUI #iOSアプリ開発 #個人開発
//}

シミュレータのスクリーンショットを添付して投稿した。

数分後、志村さんからいいねが付いた。そしてリプライ。

//quote{
3週間でここまで作れたのはすごいですね！UIのデザインセンスがエンジニアのそれじゃない。グラフィックデザイナーの強みが活きてますね。次はデータの永続化（UserDefaultsやSwiftData）に挑戦すると、アプリを閉じてもデータが消えなくなりますよ。頑張ってください！
//}

データの永続化。アプリを閉じてもデータが残る仕組み。確かに今のTodoアプリは、シミュレータを再起動するとデータがすべて消える。実用的なアプリにするには、データを保存する機能が必要だ。

翔はメモ帳に書き留めた。

@<b>{次にやること：}
 * データの永続化を学ぶ
 * Swiftful Thinkingの地図アプリチュートリアルに挑戦する
 * もっとUIを磨く
 * もっとSwiftの基礎文法を固める

リストを書き終えて、翔はふと気づいた。

やりたいことが、こんなに溢れている。

三週間前——いや、つい最近まで、翔は毎日の繰り返しの中で窒息しそうだった。デザイン会社での歯車としての日々。「これでいいのか」という自問自答。何を検索すればいいかもわからない焦燥感。

今は違う。

やりたいことがありすぎて、時間が足りない。毎晩二時間のSwiftul Thinking視聴。昼休みのコーディング。通勤電車でのドキュメント読み。会社の仕事はまだ続けている。アシスタントデザイナーとしての日々は変わらない。しかし、その「変わらない日々」の隙間に、まったく新しい世界が生まれていた。

翔は壁のNeville Brodyのポスターを見上げた。

Brodyは一九八〇年代、印刷物のデザインに革命を起こした。しかし九〇年代にはデジタルに移行し、フォントデザインやウェブデザインにも進出した。常に新しいメディアに挑戦し、デザインの境界を押し広げ続けた人だ。

「まだ何も壊していないし、何も作れていない」

翔はポスターに向かって言った。

「でも、始めた」

MacBook Airの画面には、XcodeのMyTodoプロジェクトが開いている。その画面の光は、三週間前の「冷たい光」とは、明らかに違う色をしていた。

翔はXcodeのメニューから新しいSwiftファイルを作成した。ファイル名は「MapView.swift」。

Swiftful Thinkingの次のプレイリスト——「Map App」のチュートリアル。地図アプリの作り方を学ぶシリーズだ。Landmarksチュートリアルで少しだけ触れた@<code>{MapKit}を、もっと深く掘り下げる内容。

翔はYouTubeのSwiftful Thinkingのチャンネルを開き、「Map App」プレイリストの第一話を再生した。

午前一時。

雪川翔のMacBook Airは、もう冷たい光ではなかった。

Xcodeのカラフルなシンタックスハイライトが、翔の顔を暖かく照らしている。青と紫と緑とオレンジ。コードの中に、翔の未来が書かれ始めていた。
