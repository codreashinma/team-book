= 第五章　午前一時、ふたたび

== ラスボス

九月。

純一はモバイルアプリ企業が主催するLT会に参加していた。会場は六本木のオフィスビル。百名以上のiOSエンジニアが集まっている。

四人目の登壇者は、大手メガベンチャーでiOSチームのリードを務めるエンジニアだった。テーマは「iOS開発チームの採用戦略 2025」。

純一は、そのスライドの一枚に釘付けになった。

//quote{
AIコーディングツールの普及により、ジュニアエンジニアが担っていたタスク（簡単なUI実装、バグ修正、テストコード作成）の多くをAIが代替可能に。結果として、ジュニアクラスの採用枠を縮小する企業が増加しています。
//}

会場がざわついた。

登壇者は続けた。

「誤解しないでほしいのは、ジュニアエンジニアが不要になったわけではないということです。ただ、以前は『コードが書ける』だけで採用されたジュニアポジションが、今は『AIを使いこなした上で、設計やレビューができる』レベルを求められるようになった。採用のバーが上がったんです」

純一は自分のポケットの中のiPhoneを握りしめた。そのiPhoneには、Cursorがインストールされている。AIコードエディタ。純一がiOSエンジニアになるために最も頼りにしてきたツール。

そのAIが、純一がiOSエンジニアとして就職する道を塞いでいる。

//note[AI時代のiOSエンジニア採用事情]{
2024年以降、AIコーディングツール（Cursor、GitHub Copilot、Claude Code等）の急速な普及により、モバイルエンジニアの採用市場に変化が生じている。

@<b>{ジュニア採用の縮小}：
 * AIが簡単なコーディングタスクを代替 → ジュニアの「入口」が狭くなる
 * 採用基準の上昇：コードが書けるだけでなく、設計力・レビュー力・AI活用力が求められる

@<b>{プラットフォーム別の需要変化}：
 * @<b>{Kotlin（Android）}：エンジニアの供給量が少なく、相対的に需要が高い
 * @<b>{React Native / Flutter}：クロスプラットフォーム開発の需要増。特にスタートアップで採用が増加
 * @<b>{Swift / SwiftUI}：iOS専任の求人は減少傾向。ただしネイティブ開発の品質が求められる大手企業では依然として需要あり

@<b>{逆にチャンスとなる要素}：
 * AIを@<b>{活用して}開発した実績（Cursor、Claude Code等を使った個人開発）
 * App Storeにリリースした実績（実行力の証明）
 * デザインスキルとエンジニアリングの両方ができるT型人材
//}

LT会の帰り道、純一は六本木の交差点に立ち、空を見上げた。

今まで、AIは純一にとって@<b>{最高の先生}だった。Cursorがなければ、鎌倉地図アプリもSwiftLingoも完成しなかった。AIのおかげでチュートリアルヘルを抜け出し、リジェクト対応もでき、RevenueCatの実装にも挑戦できた。

その同じAIが、今度は純一の就職の@<b>{最大の障壁}になろうとしている。

ゲームに例えるなら、AIは味方のNPCから@<b>{ラスボス}に変わったのだ。

しかし純一は、ラスボスの攻略法を知っている。このラスボスは「AIがあるからジュニアは要らない」と言う。ならば、純一は「AIを使いこなせるジュニア」になればいい。AIと戦うのではなく、AIを武器にして戦う。

純一は歩き出した。就活を、始める。


== 武器を並べる

翌日、純一はMacBook Airを開き、三つのサービスに登録した。

@<b>{Lapras}——エンジニア向けのスカウトサービス。GitHubのリポジトリ、Connpassのイベント参加・登壇履歴、Qiitaの記事などを自動的に収集し、エンジニアとしてのスコアを算出する。企業の採用担当者がスコアを見てスカウトを送る仕組みだ。

@<b>{Findy}——こちらもエンジニア向け。GitHubの活動を分析し、スキル偏差値を算出する。Connpassの登壇履歴もスコアに反映される。

@<b>{Wantedly}——「共感」を軸にしたビジネスSNS。給与ではなくミッションや文化でマッチングする。プロフィールページが名刺代わりになる。

純一はLaprasのプロフィールを開いた。自動収集された情報が並んでいる。

GitHubのリポジトリが八つ。Connpassのイベント参加履歴が十二件。もくもく会の主催が六回。LT登壇が一回。これらがスコアに反映されている。

Haruのアドバイスを思い出した。「イベントに参加するとスコアが高くなる」——純一が一年間続けてきたコミュニティ活動が、数値として可視化されている。

次に、履歴書の作成。純一はFigmaを開いた。

デザイナーとしての経験が、ここで決定的に活きた。一般的なエンジニアの履歴書はWordやGoogleドキュメントで作られるテキスト主体のものだ。純一はFigmaで、視覚的に美しい履歴書を作った。

左カラムにプロフィール写真、スキルセット、使用技術のアイコン一覧。右カラムに職務経歴とポートフォリオ。ポートフォリオセクションには、デザイナーとしての制作物と、iOSエンジニアとしてのアプリを並べた。

@<b>{Kamakura Temple}——App Storeのリンク、スクリーンショット三枚、使用技術（SwiftUI、MapKit、Core Location、MVVM）。リジェクトからリリースまでのストーリー。

@<b>{SwiftLingo}——App Storeのリンク、スクリーンショット三枚、使用技術（SwiftUI、MVVM、RevenueCat）。Shipatonハッカソンへの参加。

「グラフィックデザイナーのスキルを活かし、UIデザインから実装まで一貫して行えます」——純一の強みを一行で表現した。

履歴書のPDFを出力し、Wantedlyのプロフィールにもポートフォリオを添付した。Findyのスキル偏差値を確認する。GitHubの活動頻度と、Connpassの実績が反映されている。

純一は応募を始めた。Wantedlyの「話を聞きに行きたい」ボタンを押し、Findyの「興味がある」をタップし、Laprasのスカウトを待つ。

最初の一週間で、二十社に応募した。


== 最初の砦

十月上旬。純一にとって初めての技術面接。

相手はスキルマーケットプレイスを運営する「クラフタ」という企業。ユーザー同士がスキルを売買できるプラットフォームのiOSアプリチームに、ジュニアエンジニアの募集があった。

面接はオンライン。MacBook Airの画面に、面接官のiOSリードエンジニアの顔が映る。

「まず、自己紹介をお願いします」

純一はLT会で鍛えたプレゼンスキルを活かし、簡潔に自己紹介した。グラフィックデザイナーとしての経歴、iOSアプリ開発との出会い、二つのアプリのリリース。

面接官は頷いた。「アプリを拝見しました。Kamakura Temple、いいですね。では技術的な質問に移ります」

「まず、このアプリはどういうアーキテクチャで作っていますか？」

「MVVMです」

「なぜMVVMを採用したのですか？」

純一は答えた。「Swiftful Thinkingのチュートリアルで学んだアーキテクチャがMVVMだったので、それをベースにしました」

面接官の表情が微かに曇った。「チュートリアルで学んだから、ですか。MVVMのメリットを、他のアーキテクチャと比較して説明できますか？　例えばMVCとの違いは？」

純一は口ごもった。MVCという言葉は聞いたことがある。Model-View-Controller。しかし、MVVMとの具体的な違いを説明できるほどの理解はなかった。

「……すみません、MVCとの比較は深く理解できていません」

面接官は次の質問に移った。

「非同期処理はどういうものを使っていますか？」

「Swift Concurrencyのasync/awaitを使っています」

「Swift Concurrency以外で非同期処理を管理したことはありますか？　例えばRxSwiftやCombineは？」

「いえ、使ったことはありません……」

「テストコードを書いたことはありますか？」

「ありません」

「CI/CDツールを触ったことは？」

「ありません」

「誰かと一緒に協力してアプリを作ったことは？　GitHubでコードレビューをしたことは？」

「……ありません」

質問が進むたびに、純一の声は小さくなっていった。

面接が終わった後、純一はMacBook Airの画面を閉じ、両手で顔を覆った。

何も答えられなかった。

アプリは二つリリースした。LT会で登壇した。もくもく会を主催した。しかし、企業が求める技術知識——MVC、RxSwift、Combine、テストコード、CI/CD、コードレビュー——純一はその@<b>{どれも}経験がなかった。

個人開発とチーム開発は、まったく別の世界だった。


== 問答集

純一はNotionを開き、新しいページを作成した。タイトルは「@<b>{技術面接 問答集}」。

クラフタの面接で答えられなかった質問を書き出し、Cursorに質問しながら一つずつ回答を作成していく。

最初の項目。「@<b>{命令的UIと宣言的UIの違い}」。

//note[命令的UIと宣言的UI]{
@<b>{命令的UI（Imperative UI）}——UIKit：
 * 「@<b>{どうやって}UIを構築するか」を一手順ずつ記述する
 * 開発者がUIの状態変化を手動で管理する
 * 例：@<code>{UILabel}のテキストを変更するには、@<code>{label.text = "新しいテキスト"}と@<b>{直接操作}する

@<b>{宣言的UI（Declarative UI）}——SwiftUI：
 * 「UIが@<b>{どういう状態であるべきか}」を宣言する
 * フレームワークが状態変化に応じてUIを自動更新する
 * 例：@<code>{Text(viewModel.text)}と書けば、@<code>{viewModel.text}が変わると@<b>{自動的に}UIが更新される

@<b>{具体例で比較}：

UIKit（命令的）では、ボタンがタップされたらラベルのテキストを手動で更新する：
//}

//list[imperative_ui][UIKit：命令的UIの例][swift]{
class ViewController: UIViewController {
    let label = UILabel()
    var count = 0

    @objc func buttonTapped() {
        count += 1
        label.text = "カウント: \(count)" // 手動で更新
    }
}
//}

//note[宣言的UIの例]{
SwiftUI（宣言的）では、状態を変更するだけでUIが自動更新される：
//}

//list[declarative_ui][SwiftUI：宣言的UIの例][swift]{
struct CounterView: View {
    @State private var count = 0

    var body: some View {
        VStack {
            Text("カウント: \(count)") // 自動で更新
            Button("タップ") {
                count += 1 // 状態を変えるだけ
            }
        }
    }
}
//}

純一はこのコードを書きながら理解した。自分がSwiftUIで書いてきた@<code>{@State}の仕組みは、「宣言的UI」の根幹だったのだ。状態を変えればUIが自動で更新される。それがSwiftUIの設計思想だった。

次の項目。「@<b>{StructとClassの違い}」。

//note[StructとClassの違い]{
Swiftにおける@<code>{struct}（構造体）と@<code>{class}（クラス）の最も重要な違いは、@<b>{値型}か@<b>{参照型}かという点。

@<b>{Struct（値型）}：
 * 代入やメソッドの引数として渡すとき、@<b>{コピー}される
 * 各変数が独立したデータを持つ
 * SwiftUIの@<code>{View}は@<code>{struct}で定義される
 * スレッドセーフ（コピーされるため、複数スレッドから安全にアクセス可能）

@<b>{Class（参照型）}：
 * 代入やメソッドの引数として渡すとき、@<b>{同じインスタンスへの参照}が共有される
 * 一つのインスタンスを複数の変数が指す
 * @<code>{ObservableObject}は@<code>{class}で定義される
 * 参照カウント（ARC）によるメモリ管理

@<b>{面接での回答例}：
「Structは値型でコピーセマンティクスを持ち、Classは参照型で参照セマンティクスを持ちます。SwiftUIではViewをStructで定義し、状態管理にはObservableObjectプロトコルに準拠したClassを使います。Structはスレッドセーフであるため、SwiftUIの再描画メカニズムと相性が良いです」
//}

純一はCursorに質問した。「なぜSwiftUIのViewはStructなんですか？　Classじゃダメなんですか？」

//quote{
SwiftUIのViewがStructである理由は主に二つです。

1. パフォーマンス：Structは軽量で、ヒープではなくスタックに配置されるため、生成と破棄が高速です。SwiftUIは状態が変わるたびにViewを再生成しますが、Structなら高速に処理できます。

2. 予測可能性：Structは値型なので、ある変数を変更しても他の変数に影響しません。UIの状態管理において、この予測可能性は非常に重要です。
//}

問答集は日を追うごとに項目が増えていった。「Genericsとは何か」「クロージャとは何か」「ARCとは何か」「プロトコル指向プログラミングとは」「Swift Concurrencyの@<code>{actor}とは」——クラフタの面接で答えられなかった質問、そしてこれから聞かれるであろう質問を、純一はCursorと対話しながら一つずつ潰していった。


== 師匠の言葉

十月中旬。もくもく会で、純一はHaruに相談した。

「面接で全然答えられなくて……技術的な知識が足りないのはわかってるんですが、問答集を作っても、本当にそれで面接に通るのか不安で」

Haruは少し考えてから言った。

「純一さん、一人紹介したい人がいるんですけど。自分の師匠みたいな人で、山崎さんっていうベテランのiOSエンジニアなんですが。大手IT企業で十年以上やってて、採用面接の面接官もやってる人です。技術面接のアドバイスもらえると思います」

翌週、純一はHaruの紹介で山崎さんとオンラインで話す機会を得た。

山崎さんは穏やかだが鋭い目をした人だった。純一の履歴書とポートフォリオを事前に見てくれていた。

「水野さん、まずポートフォリオは非常にいいです。デザイナーのバックグラウンドが活きていて、他のジュニア候補者と明確に差別化されています。アプリも二つリリースしている。これは実行力の証明になります」

純一は少し安堵した。

「ただ、技術面接で苦戦しているんですね。一つ、大事なことを伝えます」

山崎さんは画面越しに純一の目を見て言った。

「面接官が聞きたいのは、@<b>{正解}ではありません。@<b>{どこまで理解していて、わからないことにどう対処するか}——それを見ています」

純一は黙って聞いた。

「例えば、『MVVMとMVCの違いは？』と聞かれて完璧に答えられなくても、『MVVMは個人開発で使っていますが、MVCは実務経験がないので深くは理解できていません。ただ、MVCではViewControllerが肥大化しやすいという課題があり、MVVMはViewModelに処理を分離することでその問題を解決すると理解しています』と答えられれば、面接官は『この人は自分の理解の範囲を正直に把握していて、学ぶ姿勢がある』と評価します」

「正直に『わかりません』と言っていいんですか？」

「@<b>{ただ『わかりません』で終わるのはダメです}。『わかりませんが、こういう理解をしています』『わかりませんが、こうやって調べます』——その後の一言が重要です。面接官は、入社後にその人が成長できるかを見ています。知識の量ではなく、@<b>{学習能力}を見ているんです」

純一はメモを取った。

山崎さんは続けた。「それから、水野さんの場合、AIを使いこなしている点は@<b>{強調すべき}です。CursorやClaude Codeを使って個人開発している経験は、今の採用市場ではプラスです。『AIに丸投げしているのではなく、AIを先生として対話しながら学習・開発している』というスタンスを伝えてください」

//note[Closure（クロージャ）とは]{
@<b>{クロージャ}は、コードの中で受け渡しや保存ができる、自己完結した機能のブロック。関数やメソッドの引数として渡したり、変数に代入できる。

@<b>{基本構文}：
//}

//list[closure_basic][クロージャの基本][swift]{
// 基本形
let greet: (String) -> String = { name in
    return "Hello, \(name)!"
}
print(greet("純一")) // "Hello, 純一!"

// トレイリングクロージャ構文
let numbers = [3, 1, 4, 1, 5, 9]
let sorted = numbers.sorted { $0 < $1 }
// [1, 1, 3, 4, 5, 9]

// SwiftUIでよく使われるクロージャ
Button("タップ") {
    // このブロックがクロージャ
    print("ボタンが押された")
}
//}

//note[クロージャが重要な理由]{
SwiftUIでは@<b>{あらゆる場所}でクロージャが使われる。@<code>{Button}のアクション、@<code>{List}のコンテンツ、@<code>{.onAppear}のハンドラ——これらすべてがクロージャ。

@<b>{面接での回答例}：
「クロージャは、Swiftにおける自己完結した機能ブロックで、変数に代入したり関数の引数として渡すことができます。SwiftUIではButtonのアクションやListのコンテンツビルダーなど、至る所でクロージャが使われています。キャプチャリストにより外部の変数を取り込める点が特徴です」
//}

山崎さんとの面談は一時間に及んだ。技術的な質問への答え方だけでなく、「志望動機」「転職理由」「入社後にやりたいこと」の伝え方まで、具体的なアドバイスをもらった。

面談の最後、山崎さんが言った。

「水野さん、デザイナーからエンジニアへの転身は、@<b>{希少な経験}です。コードを書けるデザイナーはいますが、App Storeにアプリをリリースしたデザイナーは少ない。その希少性を武器にしてください」


== 二百通の矢

十月下旬から、純一は就活に本腰を入れた。

応募数——@<b>{二百社}。

Wantedlyで百社、Findyで五十社、Laprasのスカウト経由で三十社、直接応募で二十社。iOSエンジニアの求人を見つけるたびに応募した。SwiftUI限定ではなく、UIKitの求人にも応募した。「実務未経験可」の文言がなくても、ポートフォリオの強さを信じて応募した。

結果は厳しかった。

二百社中、書類通過は@<b>{五十社}。四分の三が書類で落ちた。

一次面接に進めたのは@<b>{二十社}。

デジタルマーケティング企業「リンクス」の最終面接。面接官は技術部門のマネージャーだった。

「StructとClassの違いを説明してください」

純一は問答集で準備していた回答を、自分の言葉で伝えた。

「Structは値型で、代入時にコピーされます。Classは参照型で、同じインスタンスへの参照を共有します。SwiftUIのViewがStructで定義されているのは、値型の軽量さとスレッドセーフティが再描画の仕組みと相性が良いためです。一方、ObservableObjectはClassで定義します。参照型であることで、複数のViewから同じデータソースを共有できます」

面接官が頷いた。「では、Genericsについて説明してください」

「Genericsは、型をパラメータ化する仕組みです。例えば、@<code>{Array<Int>}と@<code>{Array<String>}は同じ@<code>{Array}という型ですが、要素の型が異なります。これにより、一つのコードで複数の型に対応できます。自分のアプリではまだ高度なGenericsは使っていませんが、SwiftUIの@<code>{ForEach}や@<code>{List}がGenericsを活用していることは理解しています」

完璧ではなかった。しかし、山崎さんのアドバイス通り、「理解している範囲」と「まだ深く理解できていない範囲」を正直に伝えた。

HR Tech企業の子会社「フィールド」の一次面接。

「宣言的UIと命令的UIの違いを説明してください」

問答集の最初の項目だ。純一は落ち着いて答えた。

「命令的UIはUIKitに代表され、『どうやってUIを構築するか』を手順で記述します。宣言的UIはSwiftUIに代表され、『UIがどういう状態であるべきか』を宣言します。状態が変われば、フレームワークが自動的にUIを更新してくれます」

「クロージャとは何ですか？」

「自己完結した機能のブロックで、変数に代入したり関数の引数として渡すことができます。SwiftUIではButtonのアクションやonAppearのハンドラなど、あらゆる場所でクロージャが使われています」

面接官が追加質問をした。「Swiftの書籍はどんなものを読みますか？」

純一は正直に答えた。「書籍は『Swift実践入門』を読みました。ただ、Swiftは言語仕様の変更が速く、2020年以降は書籍の出版が追いつけていない状況だと理解しています。そのため、Apple公式のThe Swift Programming LanguageやSwiftUI公式ドキュメント、海外のYouTubeチャンネル（Swiftful Thinking）、そしてCursorを活用して学習しています」

面接を重ねるごとに、純一の回答は洗練されていった。最初のクラフタの面接では何も答えられなかった。しかし、問答集を作り、Cursorに質問し、山崎さんにアドバイスをもらい、実際の面接で経験を積むことで、純一の技術面接力は確実に向上していた。

二次面接に進めたのは@<b>{十五社}。不採用通知が毎週のように届いた。

しかし純一は、応募を止めなかった。もくもく会を一人でも開催したように、就活も一社に落ちても次に応募した。Build in Public——純一はXに就活の状況も投稿していた。

//quote{
就活進捗。応募200社、書類通過50社、1次面接20社、2次通過15社。まだ内定なし。でも面接のたびに技術力が上がってる実感がある。面接は最高の勉強法かもしれない。#BuildInPublic #iOSエンジニア #就活
//}


== 三つ目の星

就活と並行して、純一は三つ目のアプリを開発していた。

SwiftLingoの英語学習アプリを作る中で、純一はiOSエンジニアにとって英単語の知識が重要であることを痛感していた。APIのドキュメント、エラーメッセージ、Stack Overflowの回答——すべてが英語だ。

三つ目のアプリは、@<b>{iOSエンジニア向け単語帳アプリ}。SwiftLingoがIELTS形式のリーディング問題に特化しているのに対し、こちらは単語の暗記に特化する。フラッシュカード形式で、表にSwift/iOS関連の英単語、裏に意味と使用例が表示される。

そして今回、純一は@<b>{AdMob}による広告収入に挑戦する。Shipatonで入れられなかったRevenueCatのサブスクリプション課金とは異なるアプローチだ。Haruが「個人開発の収益化はまずAdMobから始めるのがおすすめ」と言っていた。

純一はCursorに相談した。

//quote{
iOSアプリにGoogle AdMob広告を入れたいです。バナー広告とインタースティシャル広告の2種類を実装したいのですが、何から始めればいいですか？
//}

Cursorの回答に従い、まずSwift Package ManagerでGoogle Mobile Ads SDKを追加した。

//list[admob_setup][AdMob SDKの初期設定][swift]{
import GoogleMobileAds

// AppDelegateでSDKを初期化
class AppDelegate: NSObject, UIApplicationDelegate {
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions:
            [UIApplication.LaunchOptionsKey: Any]? = nil
    ) -> Bool {
        // Google Mobile Ads SDKの初期化
        MobileAds.shared.start(completionHandler: nil)
        return true
    }
}

@main
struct SwiftWordsApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self)
    var appDelegate

    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
//}

@<code>{Info.plist}にAdMobのアプリIDを設定し、App Transport Securityの例外設定も追加する。純一はCursorに確認しながら、一つずつ設定を進めた。

次に、バナー広告のView。SwiftUIでAdMobのバナー広告を表示するには、@<code>{UIViewRepresentable}を使ってUIKitのビューをSwiftUIにブリッジする必要がある。

//list[banner_ad_view][バナー広告のSwiftUI対応][swift]{
import GoogleMobileAds
import SwiftUI

struct BannerAdView: UIViewRepresentable {
    let adUnitID: String

    func makeUIView(
        context: Context
    ) -> GADBannerView {
        let bannerView = GADBannerView(
            adSize: GADAdSizeBanner
        )
        bannerView.adUnitID = adUnitID
        bannerView.rootViewController =
            UIApplication.shared.connectedScenes
                .compactMap { $0 as? UIWindowScene }
                .flatMap { $0.windows }
                .first?.rootViewController
        bannerView.load(GADRequest())
        return bannerView
    }

    func updateUIView(
        _ uiView: GADBannerView,
        context: Context
    ) {}
}

// 使用例：画面下部にバナー広告を表示
struct ContentView: View {
    var body: some View {
        VStack {
            // メインコンテンツ
            FlashCardView()

            Spacer()

            // バナー広告
            BannerAdView(
                adUnitID: "ca-app-pub-xxxxxxx/yyyyyyy"
            )
            .frame(
                width: 320,
                height: 50
            )
        }
    }
}
//}

「@<code>{UIViewRepresentable}って何ですか？」と純一はCursorに聞いた。

//quote{
UIViewRepresentableは、UIKitのビューをSwiftUIの中で使うためのプロトコルです。SwiftUIはまだすべてのUIKitの機能をカバーしていないため、UIKitのビューをブリッジして使う場面があります。AdMobのバナービューはUIKit（GADBannerView）で提供されているので、UIViewRepresentableでラップしてSwiftUIに統合します。
//}

純一はここで初めて、UIKitとSwiftUIの関係を実感した。面接で聞かれた「UIKitは使ったことありますか？」という質問。当時は「ありません」としか答えられなかったが、AdMobの実装を通じて、UIKitのビューをSwiftUIに統合する方法を学んだ。

次にインタースティシャル広告（全画面広告）。単語カードを十問ごとに表示される全画面広告だ。

//list[interstitial_ad][インタースティシャル広告の実装][swift]{
class InterstitialAdManager: NSObject,
    ObservableObject,
    GADFullScreenContentDelegate {

    @Published var isAdReady: Bool = false
    private var interstitialAd: GADInterstitialAd?

    func loadAd() {
        let request = GADRequest()
        GADInterstitialAd.load(
            withAdUnitID: "ca-app-pub-xxxxxxx/zzzzzzz",
            request: request
        ) { [weak self] ad, error in
            guard let self = self else { return }
            if let error = error {
                print("広告読み込みエラー: \(error)")
                return
            }
            self.interstitialAd = ad
            self.interstitialAd?.fullScreenContentDelegate
                = self
            self.isAdReady = true
        }
    }

    func showAd() {
        guard let ad = interstitialAd,
              let rootVC = UIApplication.shared
                  .connectedScenes
                  .compactMap({ $0 as? UIWindowScene })
                  .flatMap({ $0.windows })
                  .first?.rootViewController
        else { return }

        ad.present(fromRootViewController: rootVC)
        isAdReady = false
    }

    // 広告が閉じられたら次の広告を読み込む
    func adDidDismissFullScreenContent(
        _ ad: GADFullScreenPresentingAd
    ) {
        loadAd()
    }
}
//}

@<code>{[weak self]}——面接で聞かれそうな概念だ。純一はCursorに質問した。

//quote{
[weak self]はクロージャ内でのメモリリーク（循環参照）を防ぐためのキャプチャリストです。クロージャがselfを強参照すると、selfもクロージャを保持している場合に循環参照が発生し、メモリが解放されなくなります。weak selfを使うと、selfへの参照が弱参照になり、selfが解放されるとnilになります。
//}

ARC（Automatic Reference Counting）。循環参照。弱参照。面接の問答集に新しい項目が追加された。

純一は開発を進めながら、面接対策を同時にこなしていた。コードを書くたびに新しい技術概念に出会い、それが面接の回答力を高める。面接で答えられなかった質問が、次のコードを書くときの理解を深める。開発と就活が、螺旋のように絡み合いながら純一を引き上げていた。


== 八円の光

十一月。三つ目のアプリ「@<b>{SwiftWords}」をApp Storeにリリースした。

iOSエンジニア向けの英単語帳アプリ。フラッシュカード形式で五百語を収録。Swift/iOS開発でよく使う英単語——@<code>{fetch}、@<code>{decode}、@<code>{constraint}、@<code>{deprecated}、@<code>{assertion}——を、実際のコードでの使用例とともに学べる。

バナー広告が画面下部に常時表示され、十問ごとにインタースティシャル広告が表示される。

リリースから二週間後。純一はAdMobのダッシュボードを開いた。

@<b>{推定収益：¥8}

八円。

純一はその数字を、しばらく見つめていた。

八円。缶コーヒーも買えない金額だ。電車の初乗り運賃にも満たない。

しかし純一は、Haruの言葉を思い出した。

//quote{
@haru_iosdev: 個人開発、最初の1円が一番嬉しい。AdMobの広告収入で初月8円だったけど、自分が作ったもので収益が発生したという事実が大事。0と1の差は、1と100の差より大きい。
//}

@<b>{0と1の差は、1と100の差より大きい。}

純一のコードが、八円を生み出した。純一がCursorと対話しながら書いた@<code>{BannerAdView}、純一が設計した@<code>{InterstitialAdManager}、純一がデザインしたフラッシュカードのUI——それらが組み合わさって、八円という収益が発生した。

デザイン会社では、純一の仕事に対して月給が支払われていた。しかしそれは「会社の仕事」に対する報酬であり、純一個人の作品に対するものではなかった。

八円は、純一の@<b>{名前}で、純一の@<b>{作品}から発生した収益だ。

純一はスクリーンショットを撮り、Xに投稿した。

//quote{
3つ目のアプリ「SwiftWords」をリリースして2週間。初めての広告収入、8円。たった8円だけど、自分のコードから収益が生まれた。0と1の差は、1と100の差より大きい。ここからスケールさせていく。#AdMob #個人開発 #BuildInPublic
//}


== 内定

十二月。

最終面接まで進んだのは@<b>{七社}。

純一はそのすべてに全力で臨んだ。山崎さんのアドバイスを胸に、知っていることは正確に伝え、知らないことは正直に認めた上で、学ぶ姿勢を示した。

面接を重ねるうちに、純一は気づいた。面接官が最も興味を示すのは、技術的な知識の正確さではなく、純一の@<b>{ストーリー}だった。

グラフィックデザイナーからiOSエンジニアへの転身。AIを先生として使った学習法。リジェクトされて再申請してリリースした経験。一人でもくもく会を開催し続けた粘り強さ。海外ハッカソンで失格になりながらもアプリをリリースした実行力。

純一の一年間の旅路そのものが、最強のポートフォリオだった。

十二月中旬。二社から内定通知が届いた。

一社目は、ヘルスケアアプリを開発するスタートアップ。SwiftUI+MVVMのiOSチームに、ジュニアエンジニアとして参加する。

二社目は、教育系SaaSを提供する中規模企業。デザインとエンジニアリングの両方ができるT型人材として、UIデザインとiOS開発を兼務する。

純一は悩んだ。一社目はエンジニアとしての成長に集中できる環境。二社目はデザイナーの経験を活かせる環境。

純一は山崎さんに相談した。

「水野さんの場合、最初はエンジニアリングに集中した方がいいと思います。デザインスキルは後からでも活かせます。しかし、エンジニアとしての基礎——チーム開発、コードレビュー、CI/CD、テスト——は実務で経験しないと身につきません」

純一は一社目を選んだ。ヘルスケアアプリのスタートアップ。SwiftUIのiOSエンジニアとして、翌年の二月に入社する。

もくもく会で報告した。

「iOSエンジニア&デザイナーもくもく会 vol.10」。参加者は八名。純一、Haru、常連のメンバーに加え、新しい参加者も増えていた。

「皆さんに報告があります。来年の二月から、iOSエンジニアとして働くことになりました」

拍手が起きた。

Haruが笑顔で言った。「おめでとうございます！　でもこれはゴールじゃなくて、スタートラインですからね。これからが本番ですよ」

「もくもく会は続けます」と純一は言った。「入社しても、ここは自分の原点なので」

志村さんにもDMで報告した。

//quote{
志村さん、ご報告です。来年2月からiOSエンジニアとして就職することになりました。1年前、@Stateのバグで困っていた自分にアドバイスをくださったのが、この旅の始まりでした。本当にありがとうございます。
//}

志村さんからの返信。

//quote{
@mizuno_junichi おめでとう！1年でここまで来たのは、純一さんの行動力の賜物です。でもHaruさんの言う通り、ここからが本番。実務ではチーム開発、コードレビュー、テスト、CI/CD——個人開発にはなかった壁がたくさんあります。でも純一さんなら大丈夫。困ったらまた聞いてください。
//}

中野にも連絡した。一年前、言語交換ミートアップで出会い、コワーキングスペースに誘ってくれた中野。Ignoreのアイコンを作ることしかできなかった純一を、iOSの世界に導いてくれた人。

//quote{
中野さん、来年からiOSエンジニアとして就職します。あのとき誘ってくれなかったら、今の自分はいません。ありがとうございます。
//}

中野の返信。

//quote{
マジで？笑　純一くんすごいな。アイコン作ってもらったときから、デザインの目があるなとは思ってたけど、エンジニアにまでなるとは。今度一緒にアプリ作ろうよ。
//}


== 午前一時、ふたたび

午前一時。

純一の部屋は、MacBook Airから放たれる光に照らされている。

一年前と同じ時間。同じ部屋。同じMacBook Air。

しかし、その光の色が変わっていた。

一年前の午前一時。画面にはクライアントのデザインデータが映り、冷たい光が純一の顔を照らしていた。壁には貼りっぱなしのポスター、床には読みかけのデザイン雑誌。「これでいいのか」と吐き出した息が、白く濁ってモニターに反射していた。

今の午前一時。画面にはXcodeのプロジェクトが映っている。SwiftWordsのアップデート版。AdMobの最適化とUIの改善。純一の指がキーボードの上を走る。Cursorのチャットウィンドウには、純一の質問とAIの回答が並んでいる。

壁には、App Storeのスクリーンショットをプリントしたものが貼ってある。Kamakura Temple、SwiftLingo、SwiftWords——三つのアプリ。純一のデザイナーとしての目が選んだ構図で撮影された、美しいスクリーンショット。

床にはデザイン雑誌の代わりに、『Swift実践入門』と『The Swift Programming Language』の公式ドキュメントをプリントしたものが散らばっている。

純一はApp Storeの自分のデベロッパーページを開いた。

三つのアプリが並んでいる。

@<b>{Kamakura Temple}。ダウンロード数は三百を超えた。レビューが五件つき、平均四・二。「鎌倉旅行で使いました。コメント機能が面白い」というレビューが一件あった。

@<b>{SwiftLingo}。ダウンロード数は百五十。IELTS形式の問題が好評で、「英語の勉強とiOSの勉強が同時にできるのが画期的」というレビューがあった。

@<b>{SwiftWords}。リリースから一ヶ月で二百ダウンロード。広告収入は累計で四十二円。

合計六百五十ダウンロード。広告収入四十二円。サブスクリプション収入ゼロ。

数字としては、微々たるものだ。

しかし、純一は知っている。この数字の裏には、一年分の物語がある。

午前一時のMacBook Airの前で「これでいいのか」と呟いた夜。コワーキングスペースでアイコンを作ることしかできなかった日。「Hello, World!」がシミュレータに表示された瞬間。@<code>{@State}と@<code>{@Binding}のバグで三時間格闘した深夜。志村さんからの最初のリプライ。Swiftful ThinkingのNickの声。村田さんのもくもく会。チュートリアルヘルの絶望。Cursorとの出会い。Claude Codeの三分間の衝撃。鎌倉の寺社仏閣を巡った取材旅行。十七のピンが地図に散りばめられた日。4.2 Minimum Functionalityのリジェクトメール。石武さんの穏やかな笑顔。コメント機能の実装。App Storeに「Approved」の文字が表示された朝。初めてのLT登壇で震えた五分間。村田さんの間借りカフェ。一人で開催したもくもく会。HaruのDM。Shipatonの失格。RevenueCatの課金の壁。クラフタの面接で何も答えられなかった悔しさ。山崎さんの「正解ではなく、学ぶ姿勢を見ている」という言葉。二百社への応募。不採用メールの山。八円の広告収入。そして内定。

そのすべてが、純一の一年間だった。

GitHubのプロフィールページを開いた。十二のリポジトリ。三百以上のコントリビューション。緑色のタイルが、純一がコードを書いた日々を示している。

Connpassのプロフィールページを開いた。イベント参加二十回。もくもく会主催十回。LT登壇二回。

Xのプロフィールページを開いた。一年分のBuild in Publicの投稿が並んでいる。最初の投稿は「SwiftUIの勉強始めました」。最新の投稿は「iOSエンジニアとして内定をいただきました」。

純一はMacBook Airを閉じた。

一年前、このMacBook Airは冷たい光を放つだけの機械だった。

今は、純一の作品を世界に届け、純一に仲間を繋ぎ、純一の人生を変えた道具だ。

純一はベッドに入った。二月の入社まで、あと二ヶ月。その間にやることはたくさんある。SwiftWordsのアップデート。もくもく会の継続開催。来年のShipatonへの準備。そして、チーム開発に向けた勉強——テストコード、CI/CD、コードレビュー。

目を閉じる。

一年前、瞼の裏には何も映らなかった。ただ暗闇だけがあった。

今、瞼の裏に浮かぶのは、鎌倉大仏の穏やかな表情でも、App Storeのアイコンでもない。

それは、もくもく会のテーブルを囲む人々の顔だった。

Haru。村田さん。志村さん。山崎さん。中野。石武さん。大学生のWebデザイナー。SIerのAndroidエンジニア。フリーランスのUIデザイナー。名前も知らないLT会の聴衆。Xでいいねをくれた見知らぬフォロワー。

一人でコードを書いていた一年間が、いつの間にか、たくさんの人に支えられた旅になっていた。

純一は微笑んだ。

午前一時。部屋の闇の中で、MacBook Airのリンゴのマークが微かに光っている。

それは、もう冷たい光ではなかった。
