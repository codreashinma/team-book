= 第四章　ステージと失格

== ステージの向こう側

四月。

翔はConnpassで「iOS Indie Dev LT Night #5」というイベントを見つけた。

個人開発者向けの小規模なLT会。参加者は三十名程度で、CA.swiftのような企業主催の大規模イベントとは雰囲気が異なる。登壇枠が五枠あり、一人五分のLightning Talk形式。テーマは自由。個人開発の体験談、技術的な知見、失敗談——何でもいい。

翔は登壇申し込みフォームの前で、十五分間、手が動かなかった。

自分はまだ初心者だ。SwiftUI歴七ヶ月。リリースしたアプリは一つ。しかもチュートリアルのコードをベースにした地図アプリで、ゼロから設計したわけではない。こんな自分が人前で話す資格があるのか。

しかし、翔の指は「申し込む」ボタンを押していた。

タイトル欄に入力する。「@<b>{グラフィックデザイナーがゼロからApp Storeリリースまで——リジェクトを乗り越えた7ヶ月}」。

//note[LT会（Lightning Talk）とは]{
@<b>{LT会}とは、短時間（通常5分程度）のプレゼンテーションを複数人が連続で行うイベント形式。

@<b>{特徴}：
 * 一人あたり5分（長くても10分）の持ち時間
 * スライド枚数は10〜20枚程度が目安
 * 時間厳守（超過するとマイクを切られることも）
 * 質疑応答は登壇後の懇親会で行うのが一般的

@<b>{LTのメリット}：
 * アウトプットの習慣がつく
 * 技術コミュニティでの認知度が上がる
 * Lapras、FindyなどのエンジニアスカウトサービスでConnpassの登壇実績が評価に反映される
 * プレゼンスキルが向上する

@<b>{初心者向けのコツ}：
 * 「自分の体験談」は最強のネタ。技術的に高度でなくても、リアルな経験は聴衆の共感を得やすい
 * スライドは文字を少なく、画像やコードを大きく
 * 5分は短い。伝えたいことを一つに絞る
 * リハーサルは最低3回。時間を計って練習する
//}

翔はKeynoteを開いた。デザイナーとしてのスキルが、ここでも活きる。余白を活かしたスライドデザイン、視線誘導を意識したレイアウト、コードブロックのシンタックスハイライト。翔のスライドは、エンジニアが作るものとは明らかに異質だった。

スライドの構成を練る。五分間。三百秒。一枚あたり十五秒として二十枚。

冒頭に自己紹介。グラフィックデザイナーというバックグラウンド。iOSアプリ開発との出会い。チュートリアルヘルの苦しみ。AIコードエディタCursorとの出会い。鎌倉地図アプリの開発。4.2 Minimum Functionalityでのリジェクト。コメント機能の追加と再申請。そしてリリース。

リハーサルを三回行った。初回は七分かかった。二回目は五分三十秒。三回目でようやく四分五十秒に収まった。

イベント前夜、翔は眠れなかった。


== 五分間の物語

「iOS Indie Dev LT Night #5」の会場は、渋谷のコワーキングスペースだった。

参加者は約三十名。翔が第二章で参加したCA.swiftの百名規模とは異なり、個人開発者が中心のアットホームな雰囲気だ。名刺交換の代わりにXのアカウントを交換するのが、この界隈の流儀らしい。

翔は五番目——最後の登壇者だった。前の四人の発表を聴きながら、翔の心臓は加速していく。一人目は天気アプリのウィジェット実装の話。二人目はSwift Concurrencyのベストプラクティス。三人目はApp Storeのレビュー対応の自動化。四人目はVisionProの個人開発体験談。

みんな、自分より遥かに経験豊富に見える。

「次は、雪川さんです」

司会者に名前を呼ばれた瞬間、翔の頭が真っ白になった。

足が動く。ステージに向かう。MacBook AirをHDMIケーブルに接続する。Keynoteの最初のスライドが映し出される。

深呼吸。

「初めまして。雪川翔と申します。普段はグラフィックデザイン会社で働いています。今日は、デザイナーがゼロからApp Storeにアプリをリリースするまでの七ヶ月間について、お話しします」

会場が少しざわついた。デザイナーがLT会で登壇するのは珍しいのだろう。

翔はスライドを進めた。

チュートリアルヘルの話に、何人かが大きく頷いた。Swiftful Thinkingのチュートリアルで地図アプリを作った話に、「自分もやった」という声が上がった。4.2 Minimum Functionalityでリジェクトされた話に、苦笑いが漏れた。「あるある」と呟く声が聞こえた。

そしてコメント機能を追加してリリースした話。App Storeに自分のアプリが並んだスクリーンショット。

会場から拍手が起きた。

五分間が、一瞬で過ぎた。

登壇後の懇親会で、翔は何人もの開発者から声をかけられた。

「デザイナーからiOS開発って、すごいですね。アイコンとかスクリーンショットのクオリティが段違い」

「リジェクト対応の話、参考になりました。自分も4.2で一回やられたことがあって」

「Cursorを先生として使うっていう発想、いいですね」

翔は、初めて「iOSエンジニアのコミュニティ」に受け入れられた感覚を味わった。CA.swiftでは観客席で聴いているだけだった。今日は、ステージの上に立った。五分間だけだったが、翔の言葉が、三十人の開発者に届いた。

家に帰り、Xに投稿した。

//quote{
初めてのLT登壇してきました。「デザイナーがゼロからApp Storeリリースまで」というテーマで5分間話しました。めちゃくちゃ緊張したけど、終わったあとに何人もの方に声をかけてもらえて嬉しかった。リジェクトの話が一番反応あった笑 #iOSDev #LT #BuildInPublic
//}


== 間借りカフェ

四月下旬。翔のiPhoneに、村田さんからDMが届いた。

//quote{
翔くん、突然の連絡ですみません。実は、もくもく会をしばらく休止しようと思っています。前から話していた間借りカフェを、本格的に始めることにしました。下北沢のスペースを借りて、週末は自分のカフェとして営業したいんです。もくもく会のスペースを確保するのが難しくなりそうで……本当に申し訳ないです。
//}

翔は何度もそのメッセージを読み返した。

村田さんのもくもく会は、翔にとって「居場所」だった。初めて参加したとき、一人でTodoアプリのコードを書いていた翔に、村田さんが「何作ってるんですか？」と声をかけてくれた。GitHubを教えてくれたのも村田さんだ。CA.swiftのLT会を紹介してくれたのも村田さんだ。

その居場所が、なくなる。

翔は数日間、ぼんやりと過ごした。デザイン会社の仕事をこなし、帰宅後にXcodeを開くが、集中できない。コミュニティのない個人開発は、真っ暗な部屋で一人でコードを書いているようなものだ。

三日後、翔は村田さんにDMを送った。

//quote{
村田さん、間借りカフェ応援してます！実は相談なんですが、もくもく会、僕が引き継いで開催してもいいですか？村田さんが作ってくれたコミュニティを、できる範囲で続けたいんです。
//}

返信はすぐに来た。

//quote{
ぜひ！翔くんがやってくれるなら嬉しい。会場は自分で探す必要があるけど、下北沢だけじゃなくて渋谷とか池袋にもコワーキングスペースのドロップインがあるから。もくもく会の名前は変えてもらって大丈夫だよ。翔くんなりのコミュニティにしてほしい。
//}

翔は決意した。自分でもくもく会を開く。しかし、村田さんの「個人開発者もくもく会」をそのまま引き継ぐのではなく、翔ならではのコミュニティにしたい。

グラフィックデザイナーからiOSエンジニアを目指している自分。デザインとエンジニアリングの両方に興味がある人は、きっと他にもいるはずだ。

名前が浮かんだ。

@<b>{「iOSエンジニア&デザイナーもくもく会」}


== Haruという光

もくもく会の企画を進める中で、翔はXのタイムラインに一つのアカウントを見つけた。

@<b>{haru@iOSアプリ開発}——アカウント名は@haru_iosdev。

プロフィールには「完全未経験からiOS/Androidアプリを作ってる個人開発者。前職は飲食業の店長。アウトプット用のブログに記事を色々載せてます」と書かれている。

翔はHaruのタイムラインをスクロールした。

投稿数は数万。iOSアプリ開発の日常、つまずいたポイント、解決した方法、新しく学んだことが淡々と、しかし途切れることなく投稿されている。フォロワーは二千五百人以上。ポストの一つに「個人開発で収益を上げるための考え方」というブログ記事のリンクがあり、数百のいいねがついていた。

さらに遡ると、Haruが公開している「AdMob実装ガイド」が目に入った。Google AdMobをiOSアプリに組み込む方法を、初心者にもわかりやすく解説した長編記事だ。二十人以上が購入している。

翔は驚いた。完全未経験——飲食業の店長から。翔のグラフィックデザイナーからの転身と、境遇が似ている。しかしHaruは翔よりも遥かに先を行っていた。複数のアプリをリリースし、広告収入を得て、技術記事を書いて収益化もしている。

翔はHaruの投稿を片っ端から読んだ。

//quote{
@haru_iosdev: 個人開発、最初の1円が一番嬉しい。AdMobの広告収入で初月8円だったけど、自分が作ったもので収益が発生したという事実が大事。0と1の差は、1と100の差より大きい。
//}

//quote{
@haru_iosdev: 未経験から個人開発始めて3年。リリースしたアプリは12本。うまくいったもの、全然ダウンロードされなかったもの、色々ある。大事なのはリリースし続けること。App Storeに出さないと何もわからない。
//}

翔は思い切って、HaruにDMを送った。

//quote{
初めまして。雪川翔と申します。グラフィックデザイナーからiOSエンジニアを目指して学習中です。Haruさんの投稿にいつも勉強させてもらっています。実は近々「iOSエンジニア&デザイナーもくもく会」というイベントを自分で企画しているのですが、もしよかったら参加していただけないでしょうか。
//}

翔は送信ボタンを押した後、すぐに後悔した。面識のない相手にいきなりもくもく会の誘いを送るのは失礼だったかもしれない。

しかし、翌朝、返信が来ていた。

//quote{
翔さん、はじめまして！DMありがとうございます。プロフィール拝見しました。デザイナーからiOS開発、面白い経歴ですね。もくもく会、ぜひ参加させてください！日程決まったら教えてください。
//}

翔は、iPhoneを握りしめた。


== iOSエンジニア&デザイナーもくもく会

五月。翔はConnpassでイベントを作成した。

//note[コミュニティ運営の第一歩：Connpassでイベント作成]{
@<b>{Connpass}は、IT勉強会やイベントの告知・管理に特化したプラットフォーム。

@<b>{イベント作成の手順}：
 1. Connpassにログイン
 2. 「グループ」を作成（繰り返し開催する場合）
 3. 「イベント」を新規作成
 4. タイトル、日時、会場、定員、説明文を入力
 5. 参加費（無料 or 有料）を設定
 6. 公開して集客

@<b>{もくもく会運営のコツ}：
 * 最初は小規模（5〜10名）で始める
 * 会場はコワーキングスペースのドロップインが手軽
 * 開始時に自己紹介タイム、終了時に成果発表タイムを設けると参加者同士の交流が生まれる
 * 人が集まらなくても、定期開催を続けることが大切
 * SNSでの告知はイベント1週間前と前日の2回

@<b>{エンジニアにとってのメリット}：
 * Lapras、Findyなどのスカウトサービスでは、Connpassの参加・登壇履歴がスコアに反映される
 * 主催者としての実績も評価される
//}

イベントタイトルは「iOSエンジニア&デザイナーもくもく会 vol.1」。会場は渋谷のコワーキングスペース。定員十名。参加費は会場のドロップイン料金のみ。

説明文には、翔のこだわりを詰め込んだ。

//quote{
iOSアプリ開発者とデザイナーのためのもくもく会です。個人開発、業務、学習——何でもOK。エンジニアとデザイナーが同じ空間で作業することで、普段とは違う視点が得られるかもしれません。初心者大歓迎。一人で黙々と作業するもよし、困ったことを相談するもよし。
//}

イベントを公開して一週間。参加登録は——三名。

翔と、Haruと、もう一人。

定員十名に対して三名。翔は少し落ち込んだ。村田さんのもくもく会は毎回七〜八名は集まっていた。

当日。渋谷のコワーキングスペースに三人が集まった。

Haruは、翔が想像していたよりも穏やかな雰囲気の人だった。年齢は翔より少し上。飲食業の店長を辞めてから独学でプログラミングを始め、三年でiOSアプリを十二本リリースしたという。

「最初のアプリは本当にひどかったですよ」とHaruは笑った。「ボタンを押したら画面が真っ白になるバグを放置したままリリースして、レビューで星一つをもらいました」

もう一人の参加者は、大学生のWebデザイナーだった。SwiftUIに興味があり、Figmaのデザインをそのままアプリにしたいと話していた。

三人で自己紹介を済ませ、それぞれの作業に入った。翔は次のアプリのアイデアを考えていた。Haruは既存アプリのアップデートを進めていた。大学生はSwiftUIのチュートリアルを写経していた。

二時間後の成果発表タイム。

Haruが翔に言った。

「翔さん、もくもく会の主催を始めたのはすごくいい判断ですよ。コミュニティを運営する側に回ると、自然と人が集まってきます。最初は少人数でも、続けることが大事です」

「人が集まらなかったらどうしよう、って不安なんですけど」

「一人でも開催するんです。参加者がゼロの回があっても、自分一人でもくもく会を開催する。それをXに投稿する。そうすると『この人は本気でやってるんだな』と思ってもらえて、次は来てくれる人が増えます」

翔はHaruの言葉をメモした。

実際、翌月のvol.2は参加者二名（翔とHaru）だった。翔は一人でも開催すると決めていたので、Haruが来てくれただけでも嬉しかった。vol.3は翔一人だけの回もあった。それでも翔は会場に行き、一人で作業し、Xに投稿した。

//quote{
iOSエンジニア&デザイナーもくもく会 vol.3、今日は参加者自分だけでした。でも一人でも開催する。これが自分のルール。黙々とアプリ開発しました。#もくもく会 #iOSDev #BuildInPublic
//}

vol.4には、Xの投稿を見た新しい参加者が二人来た。


== 海を越えるハッカソン

六月。翔のXのタイムラインに、一つのツイートが流れてきた。

//quote{
RevenueCat Shipaton 2025 is now open! Build a mobile app in 2 months, integrate RevenueCat for monetization, and share your progress publicly. Total prizes: $350,000+. Ship your app, share your journey, and win big. #Shipaton #RevenueCat #BuildInPublic
//}

@<b>{RevenueCat}——モバイルアプリのサブスクリプション課金を簡単に実装できるサービス。@<b>{Shipaton}——RevenueCatが主催するグローバルなハッカソンだ。

翔はリンクを開いた。

参加条件は三つ。

 * 二ヶ月以内にモバイルアプリを開発してApp StoreまたはGoogle Playにリリースすること
 * RevenueCatのSDKを使ったサブスクリプション課金を実装すること
 * 開発過程をBuild in Publicで共有すること

賞金総額は三十五万ドル——日本円にして五千万円以上。しかし翔にとって、賞金よりも重要だったのは三つ目の条件だ。Build in Public——翔がすでにやっていることだ。

翔はHaruにDMで相談した。

//quote{
RevenueCatのShipatonっていうハッカソン知ってますか？参加してみたいんですけど、海外のハッカソンで英語だし、課金実装もやったことなくて……
//}

Haruの返信。

//quote{
Shipatonいいですね！自分も去年エントリーだけして結局出せなかったんですが笑。RevenueCatの課金実装は、SDKがかなり親切なのでドキュメント読めばいけると思いますよ。英語は……まあBuild in Publicの投稿は英語でやった方がいいですけど、短い文でOKです。何作るか決めました？
//}

翔は考えた。二つ目のアプリ。チュートリアルベースではなく、完全にゼロから作るオリジナルアプリ。サブスクリプション課金が自然に組み込めるもの。

翔は自分の経験を振り返った。iOSエンジニアを目指す中で、最も苦労したことの一つが@<b>{英語}だった。Swiftful Thinkingの動画は英語。Apple公式ドキュメントは英語。Stack Overflowの回答は英語。エラーメッセージも英語。iOSエンジニアにとって、英語は避けて通れない。

そこで、アイデアが浮かんだ。

@<b>{iOSエンジニア向けの英語学習アプリ}。

IELTS（International English Language Testing System）のリーディング・リスニング形式を採用しつつ、コンテンツはiOS開発に特化する。例えば、リーディング問題の題材がSwiftの技術記事。リスニング問題の音声がWWDCのプレゼンテーション。選択肢にSwiftUIのAPIが登場する。

英語を学びながら、iOSの知識も身につく。一石二鳥のアプリ。

翔はShipatonにエントリーした。


== 英語とSwiftの交差点

アプリの名前は「@<b>{SwiftLingo}」に決めた。

翔はCursorを開き、データモデルの設計から始めた。IELTS形式のクイズアプリに必要なものは何か。

//quote{
SwiftLingoという英語学習アプリを作りたいです。IELTS形式のリーディング問題をベースに、iOSエンジニア向けの英語学習ができるアプリです。まずデータモデルを設計したいのですが、どういう構造体が必要ですか？
//}

Cursorが提案したモデルをもとに、翔は自分で構造体を書いていった。

//list[question_model][Question：クイズのデータモデル][swift]{
enum QuestionType: String, Codable {
    case reading      // リーディング問題
    case listening    // リスニング問題
    case vocabulary   // 単語問題
}

enum Difficulty: Int, Codable, Comparable {
    case beginner = 1
    case intermediate = 2
    case advanced = 3

    static func < (lhs: Difficulty, rhs: Difficulty) -> Bool {
        lhs.rawValue < rhs.rawValue
    }
}

struct Question: Identifiable, Codable {
    let id: UUID
    let type: QuestionType
    let difficulty: Difficulty
    let passage: String          // 問題文（英語）
    let questionText: String     // 質問（英語）
    let choices: [String]        // 選択肢（4択）
    let correctAnswerIndex: Int  // 正解のインデックス
    let explanation: String      // 解説（日本語）
    let relatedTopic: String     // 関連するiOS技術トピック

    init(
        type: QuestionType,
        difficulty: Difficulty,
        passage: String,
        questionText: String,
        choices: [String],
        correctAnswerIndex: Int,
        explanation: String,
        relatedTopic: String
    ) {
        self.id = UUID()
        self.type = type
        self.difficulty = difficulty
        self.passage = passage
        self.questionText = questionText
        self.choices = choices
        self.correctAnswerIndex = correctAnswerIndex
        self.explanation = explanation
        self.relatedTopic = relatedTopic
    }
}
//}

翔は@<code>{QuestionType}にenumを使った。第三章で学んだ@<code>{LocationCategory}と同じパターンだ。学んだ技術が、次のアプリで再利用できる。螺旋階段を上るように、少しずつ高い場所に到達している実感があった。

次にViewModelだ。クイズの進行状態を管理し、正答率を計算する。

//list[quiz_viewmodel][QuizViewModel：クイズの進行管理][swift]{
class QuizViewModel: ObservableObject {
    @Published var questions: [Question] = []
    @Published var currentQuestionIndex: Int = 0
    @Published var score: Int = 0
    @Published var isQuizCompleted: Bool = false
    @Published var selectedAnswerIndex: Int? = nil
    @Published var showExplanation: Bool = false

    // 現在の問題を取得
    var currentQuestion: Question? {
        guard currentQuestionIndex < questions.count else {
            return nil
        }
        return questions[currentQuestionIndex]
    }

    // 正答率を計算（パーセント）
    var accuracyPercentage: Double {
        guard currentQuestionIndex > 0 else { return 0.0 }
        return Double(score) / Double(currentQuestionIndex) * 100.0
    }

    // 回答を送信
    func submitAnswer(_ selectedIndex: Int) {
        selectedAnswerIndex = selectedIndex

        if let question = currentQuestion,
           selectedIndex == question.correctAnswerIndex {
            score += 1
        }

        showExplanation = true
    }

    // 次の問題に進む
    func nextQuestion() {
        selectedAnswerIndex = nil
        showExplanation = false

        if currentQuestionIndex + 1 < questions.count {
            currentQuestionIndex += 1
        } else {
            isQuizCompleted = true
        }
    }

    // クイズをリセット
    func resetQuiz() {
        currentQuestionIndex = 0
        score = 0
        isQuizCompleted = false
        selectedAnswerIndex = nil
        showExplanation = false
        questions.shuffle()
    }
}
//}

@<code>{@Published}と@<code>{ObservableObject}——第二章で学んだMVVMパターンがここでも活きる。ViewModel がデータと状態を管理し、Viewは表示に専念する。翔はこのパターンをKamakura Templeの@<code>{LocationsViewModel}で体得していたので、スムーズに書けた。

問題データのサンプル。

//list[sample_question][サンプル問題：SwiftUIに関するリーディング問題][swift]{
let sampleQuestion = Question(
    type: .reading,
    difficulty: .intermediate,
    passage: """
    SwiftUI uses a declarative syntax, which means you \
    state what your user interface should do. For example, \
    you can write that you want a list of items consisting \
    of text fields, then describe alignment, font, and \
    color for each field. Your code is simpler and easier \
    to read than ever before, saving you time and \
    maintenance.
    """,
    questionText: "According to the passage, what is the "
        + "main advantage of SwiftUI's declarative syntax?",
    choices: [
        "It makes apps run faster",
        "It simplifies code and improves readability",
        "It eliminates the need for testing",
        "It automatically generates UI designs"
    ],
    correctAnswerIndex: 1,
    explanation: "SwiftUIの宣言的構文の主な利点は、コードがシンプルになり"
        + "読みやすくなることです。「Your code is simpler and easier to "
        + "read than ever before」と明記されています。",
    relatedTopic: "SwiftUI Declarative Syntax"
)
//}

Cursorに質問しながらUIを組み立てていく。問題表示画面、選択肢のボタン、解説表示、正答率のプログレスバー。デザイナーとしてのスキルを活かし、読みやすいタイポグラフィ、目に優しいカラーパレット、直感的な操作フローを設計した。

三週間の開発期間で、SwiftLingoの基本機能が完成した。リーディング問題三十問、単語問題五十問をCursorと協力して作成した。


== RevenueCatの壁

アプリの基本機能はできた。次は、Shipatonの参加条件であるRevenueCatの課金実装だ。

翔はRevenueCatの公式ドキュメントを開いた。

//quote{
RevenueCatのSDKをSwiftLingoに導入したいです。サブスクリプション課金を実装するには何から始めればいいですか？
//}

Cursorが教えてくれた手順は、大きく分けて四つだった。

 1. App Store Connectでサブスクリプション商品を設定する
 2. RevenueCatのダッシュボードでプロジェクトを作成し、Offeringsを設定する
 3. アプリにRevenueCat SDKを導入する
 4. PaywallViewを実装する

まずはSDKの導入だ。Swift Package Manager（SPM）を使う。

//list[revenuecat_setup][RevenueCat SDKの初期設定][swift]{
import RevenueCat

// AppDelegateまたはApp構造体でSDKを初期化
@main
struct SwiftLingoApp: App {

    init() {
        // RevenueCatのAPIキーで初期化
        Purchases.configure(
            withAPIKey: "appl_xxxxxxxxxxxxx"
        )
        // デバッグログを有効化（開発中のみ）
        Purchases.logLevel = .debug
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
//}

@<code>{Purchases.configure}でSDKを初期化する。APIキーはRevenueCatのダッシュボードから取得する。翔はダッシュボードにログインし、プロジェクトを作成し、App Store Connectの共有シークレットを入力した。

次に、@<b>{Offerings}の概念を理解する必要があった。

//note[RevenueCatの課金モデル]{
RevenueCatでは、課金に関する概念が階層的に整理されている。

@<b>{Product}：App Store Connectで作成するサブスクリプション商品（例：月額プラン、年額プラン）。

@<b>{Entitlement}：ユーザーがアクセスできる機能のグループ（例：「プレミアム」）。一つのEntitlementに複数のProductを紐づけられる。

@<b>{Offering}：ユーザーに提示する商品パッケージ。ダッシュボードから変更可能で、アプリのアップデートなしに表示する商品を変えられる。

@<b>{Package}：Offering内の個々の商品（例：月額パッケージ、年額パッケージ）。

この階層構造により、アプリのコードを変更せずに、ダッシュボードから課金プランの構成を変更できる。
//}

翔はApp Store Connectでサブスクリプション商品を作成した。月額プラン（480円）と年額プラン（4,800円）。RevenueCatのダッシュボードでEntitlement「premium」を作成し、両プランを紐づけた。

次に、アプリ内でOfferingsを取得するコードを書く。

//list[fetch_offerings][Offeringsの取得][swift]{
class SubscriptionViewModel: ObservableObject {
    @Published var offerings: Offerings? = nil
    @Published var customerInfo: CustomerInfo? = nil
    @Published var isPremium: Bool = false

    func fetchOfferings() async {
        do {
            let offerings = try await Purchases.shared
                .offerings()
            await MainActor.run {
                self.offerings = offerings
            }
        } catch {
            print("Offerings取得エラー: \(error)")
        }
    }

    func checkSubscriptionStatus() async {
        do {
            let customerInfo = try await Purchases.shared
                .customerInfo()
            await MainActor.run {
                self.customerInfo = customerInfo
                self.isPremium = customerInfo
                    .entitlements["premium"]?.isActive == true
            }
        } catch {
            print("ステータス確認エラー: \(error)")
        }
    }

    func purchase(package: Package) async {
        do {
            let result = try await Purchases.shared
                .purchase(package: package)
            await MainActor.run {
                self.isPremium = result.customerInfo
                    .entitlements["premium"]?.isActive == true
            }
        } catch {
            print("購入エラー: \(error)")
        }
    }
}
//}

@<code>{async/await}——第二章のLT会で聞いたSwift Concurrencyの構文だ。あのときは理解できなかったが、Cursorに教わりながら実際に書いてみると、非同期処理を同期処理のように書ける便利さがわかった。

そしてPaywall画面の実装。ユーザーに有料プランを提示する画面だ。

//list[paywall_view][PaywallView：課金画面][swift]{
struct PaywallView: View {
    @StateObject private var viewModel
        = SubscriptionViewModel()
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack(spacing: 24) {
            // ヘッダー
            Text("SwiftLingo Premium")
                .font(.largeTitle)
                .fontWeight(.bold)

            Text("すべての問題にアクセスして\niOS英語力を加速させよう")
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)

            // 特典リスト
            VStack(alignment: .leading, spacing: 12) {
                FeatureRow(
                    icon: "checkmark.circle.fill",
                    text: "全300問以上の問題が解き放題"
                )
                FeatureRow(
                    icon: "checkmark.circle.fill",
                    text: "リスニング問題（WWDC音声）"
                )
                FeatureRow(
                    icon: "checkmark.circle.fill",
                    text: "弱点分析と学習レポート"
                )
            }
            .padding()

            // 価格ボタン
            if let offering = viewModel.offerings?
                .current {
                ForEach(
                    offering.availablePackages,
                    id: \.identifier
                ) { package in
                    Button {
                        Task {
                            await viewModel
                                .purchase(package: package)
                        }
                    } label: {
                        VStack {
                            Text(
                                package
                                    .storeProduct
                                    .localizedTitle
                            )
                            Text(
                                package
                                    .storeProduct
                                    .localizedPriceString
                            )
                            .font(.headline)
                        }
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(12)
                    }
                }
            }

            // 利用規約・プライバシーポリシー
            HStack {
                Button("利用規約") { /* URL */ }
                Text("·")
                Button("プライバシーポリシー") { /* URL */ }
                Text("·")
                Button("復元") {
                    Task {
                        await viewModel
                            .checkSubscriptionStatus()
                    }
                }
            }
            .font(.caption)
            .foregroundColor(.secondary)
        }
        .padding()
        .task {
            await viewModel.fetchOfferings()
        }
    }
}

struct FeatureRow: View {
    let icon: String
    let text: String

    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(.blue)
            Text(text)
        }
    }
}
//}

翔はこのコードをCursorと対話しながら書き上げた。一行ずつ、「なぜこう書くのか」を確認しながら。

しかし、ここからが地獄だった。

App Store Connectでのサブスクリプション商品の設定が、想像以上に複雑だった。サブスクリプショングループの作成、価格の設定、審査用の情報入力、Sandbox環境でのテスト——一つひとつの手順でつまずいた。

Sandboxテスターアカウントを作成し、テスト購入を試みる。しかし、Sandbox環境は不安定で、購入が完了しないことがあった。RevenueCatのダッシュボードにはイベントが届かない。デバッグログを確認すると、@<code>{STORE_PROBLEM}というエラーが出ている。

翔はCursorに質問し、Stack Overflowを検索し、RevenueCatのDiscordコミュニティに質問を投げた。英語で。拙い英語だったが、コミュニティのメンバーが丁寧に回答してくれた。

しかし、時間が足りなかった。


== 失格、しかし前へ

Shipatonの締め切りは七月末だった。

SwiftLingoのアプリ自体は完成していた。リーディング問題、単語問題、スコアトラッキング、学習レポート——基本機能はすべて動いている。UIもデザイナーとしての技量を活かし、美しく仕上がっていた。翔はApp Storeに審査を提出し、三日後に承認された。二つ目のアプリリリース。

しかし、RevenueCatの課金実装が完成していない。

Sandbox環境でのテスト購入は成功するようになったが、実際のApp Storeでサブスクリプション商品を有効にするための審査が通っていなかった。App Store Connectの「Subscriptions」セクションで、商品のステータスが「Waiting for Review」のまま動かない。

翔はApp Store Connectのステータスを一時間おきに確認した。「Waiting for Review」。「Waiting for Review」。変わらない。

七月三十一日の深夜。

Shipatonの提出フォームを開いた。アプリのApp StoreリンクとRevenueCatのダッシュボードのスクリーンショットを添付する欄がある。アプリのリンクは提出できる。しかし、RevenueCatの課金が動作していない状態では、参加条件を満たさない。

翔は提出フォームの「Submit」ボタンの前で、五分間、固まっていた。

結局、翔は正直に書いた。

//quote{
The app (SwiftLingo) has been released on the App Store. However, I was unable to complete the RevenueCat subscription implementation by the deadline. The subscription product is still under review in App Store Connect. I understand this may not meet the Shipaton requirements, but I wanted to share my Build in Public journey.
//}

数日後、Shipatonの結果が発表された。翔の名前はリストになかった。@<b>{失格}。

予想はしていた。しかし、結果を目にした瞬間、胸の奥が鈍く痛んだ。

二ヶ月間、アプリを作り、Build in Publicで過程を共有し、英語で投稿し、RevenueCatのドキュメントと格闘した。その時間は無駄だったのか。

翔はXに投稿した。

//quote{
RevenueCat Shipaton、課金実装が間に合わず失格でした。悔しい。でもSwiftLingoは無事App Storeにリリースできたし、RevenueCatの仕組みは理解できた。来年のShipatonでは必ず入賞する。#Shipaton #RevenueCat #BuildInPublic
//}

投稿にはHaruからリプライが来た。

//quote{
@yukikawa_sho 失格は悔しいですよね。でも2ヶ月でアプリ1本リリースして、課金の仕組みも一通り学べたのは大きい。RevenueCatの実装は一度経験すれば次は早いですよ。来年一緒にShipaton出ましょう！
//}

志村さんからもリプライが来た。

//quote{
@yukikawa_sho 海外のハッカソンにエントリーして、英語でBuild in Publicしたこと自体がすごい。結果は失格でも、過程で得たものは確実に残る。App Store Connect周りの知見は実務でも使うから、いい経験です。
//}

翔はリプライを読みながら、少しだけ気持ちが軽くなった。

失格は事実だ。しかし、翔の手元にはSwiftLingoというアプリと、RevenueCatの実装知識と、英語でBuild in Publicした経験がある。これらは、失格という結果では消えない。


== 二つの星

八月。

翔はApp Storeの自分のデベロッパーページを開いた。

二つのアプリが並んでいる。

@<b>{Kamakura Temple}——鎌倉の寺社仏閣マップアプリ。十七箇所の寺・神社・大仏をカテゴリ別ピンで表示し、現在地にコメントを残せる。

@<b>{SwiftLingo}——iOSエンジニア向け英語学習アプリ。IELTS形式のリーディング問題と単語問題で、英語とiOSの知識を同時に身につけられる。

一つ目はチュートリアルベースの改変アプリ。二つ目は完全にゼロから設計したオリジナルアプリ。翔の成長の軌跡が、App Storeに刻まれていた。

もくもく会の日。

「iOSエンジニア&デザイナーもくもく会 vol.6」。参加者は六名に増えていた。翔とHaru、大学生のWebデザイナー（vol.1からの常連）、SIerのAndroidエンジニア、フリーランスのUIデザイナー、そしてSwiftUI初心者の会社員。

成果発表タイムで、翔はShipatonの経験を共有した。失格になったこと、しかしアプリはリリースできたこと、RevenueCatの仕組みを学べたこと。

Haruが言った。

「翔さん、アプリ二つリリースしたのは本当にすごいですよ。これ、就活で武器になります」

「就活……ですか？」

「個人開発でアプリをリリースした経験って、企業から見ると@<b>{実行力の証明}なんですよ。特に翔さんの場合、デザイナーのバックグラウンドがあって、自分でアプリを設計して、リジェクト対応して、課金実装にも挑戦した。これ、ポートフォリオとしてかなり強い」

翔は、就活のことをまだ本気で考えていなかった。今はアプリを作ることに夢中で、就職活動は「いつか」の話だと思っていた。

しかしHaruの言葉が、翔の意識を変えた。

「あと、翔さんのGitHubのプロフィール、もう少し充実させた方がいいですよ。リポジトリの説明文とREADMEを整えると、採用担当者に見てもらいやすくなります。あと、このもくもく会の主催者っていう実績もLaprasやFindyに反映されるんで」

翔はメモを取った。GitHub。README。Lapras。Findy。まだ知らない世界が広がっている。

もくもく会が終わった後、翔は一人で渋谷の街を歩いた。

十ヶ月前の自分を思い出した。午前一時、MacBook Airの冷たい光の前で「これでいいのか」と呟いていた自分。デザインデータの色味を微調整するだけの日々に、息苦しさを感じていた自分。

今の翔は違う。App Storeに二つのアプリがあり、もくもく会を主催し、LT会で登壇し、海外のハッカソンにエントリーした。失敗もした。リジェクトされた。失格になった。しかし、そのすべてが翔のスキルとして、経験として、蓄積されている。

翔はスマートフォンを取り出し、メモ帳を開いた。

@<b>{次にやること：}
 * GitHubプロフィールを整える
 * LaprasとFindyに登録する
 * 三つ目のアプリを企画する（AdMob広告収入を入れる）
 * 就活の準備を始める
 * もくもく会を継続開催する

翔は渋谷駅に向かった。改札をくぐり、ホームのベンチに座る。

iPhoneのApp Storeを開いた。「Kamakura Temple」と「SwiftLingo」。二つのアイコンが並んでいる。Kamakura Templeの寺のアイコンは翔がFigmaでデザインした。SwiftLingoのアイコンは、英語のアルファベットとSwiftのロゴを組み合わせたデザインだ。

二つの星。

まだ小さい。ダウンロード数は両方合わせても百に届かない。広告収入はゼロ。サブスクリプションの売上もゼロ。

しかし、翔の星は確かにApp Storeの空に輝いている。

電車が来た。翔はiPhoneをポケットに入れ、立ち上がった。

帰ったら、Haruに教わったLaprasに登録しよう。そして三つ目のアプリのアイデアを考えよう。Haruが言っていた「AdMobの広告収入」——翔が次に挑戦すべき収益化の方法だ。

車窓から見える夜景が流れていく。十ヶ月前は、この景色がただの光の羅列に見えていた。今は、一つ一つの光がアプリのアイコンに見える。誰かが作った、誰かの作品。

翔は、自分もその光の一つになった。
